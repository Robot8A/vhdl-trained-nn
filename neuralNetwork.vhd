-- File: neuralNetwork.vhd
-- Generated by: vhdl.py
-- Author: HÃ©ctor Ochoa Ortiz
-- Datetime: 2020-01-12T08:21:09.114160Z

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;

use work.FloatPt.all;
use work.activationFunct.all;

ENTITY neuralNetwork IS
END neuralNetwork;

ARCHITECTURE behavior OF neuralNetwork IS

-- Clock period definitions
constant CLK_period: time := 10 ns;

--***********--
--* SIGNALS *--
--***********--

SIGNAL clk, reset : std_logic;
type NN_STATE is (NN_BEGIN, LAYER0_MUL, LAYER0_ADD0, LAYER0_ADD0ACK, LAYER0_ADD1, LAYER0_ADD1ACK, LAYER0_ADD2, LAYER0_ADD2ACK, LAYER0_ADD3, LAYER0_ADD3ACK, LAYER0_ADD4, LAYER0_ADD4ACK, LAYER0_ADD5, LAYER0_ADD5ACK, LAYER0_ADD6, LAYER0_ADD6ACK, LAYER0_ADDBIAS, LAYER0_ACTFUNC, LAYER1_MUL, LAYER1_ADD0, LAYER1_ADD0ACK, LAYER1_ADD1, LAYER1_ADD1ACK, LAYER1_ADD2, LAYER1_ADD2ACK, LAYER1_ADD3, LAYER1_ADD3ACK, LAYER1_ADD4, LAYER1_ADD4ACK, LAYER1_ADD5, LAYER1_ADD5ACK, LAYER1_ADD6, LAYER1_ADD6ACK, LAYER1_ADDBIAS, LAYER1_ACTFUNC, LAYER2_MUL, LAYER2_ADD0, LAYER2_ADD0ACK, LAYER2_ADD1, LAYER2_ADD1ACK, LAYER2_ADD2, LAYER2_ADD2ACK, LAYER2_ADD3, LAYER2_ADD3ACK, LAYER2_ADDBIAS, LAYER2_ACTFUNC, NN_END);
signal state: NN_STATE;
SIGNAL input0, input1, input2, input3, input4, input5, input6, input7 : std_logic_vector(31 downto 0); -- Input layer
SIGNAL final_result0 : std_logic_vector(31 downto 0);

--- Layer 0 ---
-- neuron 0 --
CONSTANT bias0_0 : std_logic_vector(31 downto 0) := "10111000010100001001011110000001";
CONSTANT W0_0_0 : std_logic_vector(31 downto 0) := "00111110010101001001101010110110";
CONSTANT W0_0_1 : std_logic_vector(31 downto 0) := "10111101010000100101111101101100";
CONSTANT W0_0_2 : std_logic_vector(31 downto 0) := "00111011110110101101001100000000";
CONSTANT W0_0_3 : std_logic_vector(31 downto 0) := "00111110101000101011110000111100";
CONSTANT W0_0_4 : std_logic_vector(31 downto 0) := "10111110110111010110100010110011";
CONSTANT W0_0_5 : std_logic_vector(31 downto 0) := "10111110000110100101011100011111";
CONSTANT W0_0_6 : std_logic_vector(31 downto 0) := "00111110111100001101010111110001";
CONSTANT W0_0_7 : std_logic_vector(31 downto 0) := "00111111000101001001111110100010";
SIGNAL rmul0_0_0, rmul0_0_1, rmul0_0_2, rmul0_0_3, rmul0_0_4, rmul0_0_5, rmul0_0_6, rmul0_0_7 : std_logic_vector(31 downto 0); -- Multiplication
SIGNAL go_mul0_0_0, done_mul0_0_0, go_mul0_0_1, done_mul0_0_1, go_mul0_0_2, done_mul0_0_2, go_mul0_0_3, done_mul0_0_3, go_mul0_0_4, done_mul0_0_4, go_mul0_0_5, done_mul0_0_5, go_mul0_0_6, done_mul0_0_6, go_mul0_0_7, done_mul0_0_7 : std_logic;
SIGNAL A0_0, B0_0, radd0_0 : std_logic_vector(31 downto 0); -- Addition
SIGNAL go_add0_0, done_add0_0 : std_logic;
SIGNAL iaf0_0, result0_0 : std_logic_vector(31 downto 0); -- Activation function
SIGNAL go_af0_0, done_af0_0 : std_logic;
-- neuron 1 --
CONSTANT bias0_1 : std_logic_vector(31 downto 0) := "00000000000000000000000000000000";
CONSTANT W0_1_0 : std_logic_vector(31 downto 0) := "00111110011000010010011100010000";
CONSTANT W0_1_1 : std_logic_vector(31 downto 0) := "00111110100100000110111010110000";
CONSTANT W0_1_2 : std_logic_vector(31 downto 0) := "00111110111011100001110001111110";
CONSTANT W0_1_3 : std_logic_vector(31 downto 0) := "10111100000000001110010010000000";
CONSTANT W0_1_4 : std_logic_vector(31 downto 0) := "00111111000101111000101010011111";
CONSTANT W0_1_5 : std_logic_vector(31 downto 0) := "00111111000001000001000110000011";
CONSTANT W0_1_6 : std_logic_vector(31 downto 0) := "10111100100110011011001110100000";
CONSTANT W0_1_7 : std_logic_vector(31 downto 0) := "10111110101001000111100010011011";
SIGNAL rmul0_1_0, rmul0_1_1, rmul0_1_2, rmul0_1_3, rmul0_1_4, rmul0_1_5, rmul0_1_6, rmul0_1_7 : std_logic_vector(31 downto 0); -- Multiplication
SIGNAL go_mul0_1_0, done_mul0_1_0, go_mul0_1_1, done_mul0_1_1, go_mul0_1_2, done_mul0_1_2, go_mul0_1_3, done_mul0_1_3, go_mul0_1_4, done_mul0_1_4, go_mul0_1_5, done_mul0_1_5, go_mul0_1_6, done_mul0_1_6, go_mul0_1_7, done_mul0_1_7 : std_logic;
SIGNAL A0_1, B0_1, radd0_1 : std_logic_vector(31 downto 0); -- Addition
SIGNAL go_add0_1, done_add0_1 : std_logic;
SIGNAL iaf0_1, result0_1 : std_logic_vector(31 downto 0); -- Activation function
SIGNAL go_af0_1, done_af0_1 : std_logic;
-- neuron 2 --
CONSTANT bias0_2 : std_logic_vector(31 downto 0) := "00111000010100110000110011011001";
CONSTANT W0_2_0 : std_logic_vector(31 downto 0) := "10111110100101110010001010010000";
CONSTANT W0_2_1 : std_logic_vector(31 downto 0) := "10111111000101111011000101101001";
CONSTANT W0_2_2 : std_logic_vector(31 downto 0) := "10111110111010111111001110011111";
CONSTANT W0_2_3 : std_logic_vector(31 downto 0) := "10111111000001111100010100100100";
CONSTANT W0_2_4 : std_logic_vector(31 downto 0) := "00111111000111110100001010100100";
CONSTANT W0_2_5 : std_logic_vector(31 downto 0) := "00111111000110011000100110100101";
CONSTANT W0_2_6 : std_logic_vector(31 downto 0) := "10111110100010001001100101011011";
CONSTANT W0_2_7 : std_logic_vector(31 downto 0) := "10111101110111000111011101001011";
SIGNAL rmul0_2_0, rmul0_2_1, rmul0_2_2, rmul0_2_3, rmul0_2_4, rmul0_2_5, rmul0_2_6, rmul0_2_7 : std_logic_vector(31 downto 0); -- Multiplication
SIGNAL go_mul0_2_0, done_mul0_2_0, go_mul0_2_1, done_mul0_2_1, go_mul0_2_2, done_mul0_2_2, go_mul0_2_3, done_mul0_2_3, go_mul0_2_4, done_mul0_2_4, go_mul0_2_5, done_mul0_2_5, go_mul0_2_6, done_mul0_2_6, go_mul0_2_7, done_mul0_2_7 : std_logic;
SIGNAL A0_2, B0_2, radd0_2 : std_logic_vector(31 downto 0); -- Addition
SIGNAL go_add0_2, done_add0_2 : std_logic;
SIGNAL iaf0_2, result0_2 : std_logic_vector(31 downto 0); -- Activation function
SIGNAL go_af0_2, done_af0_2 : std_logic;
-- neuron 3 --
CONSTANT bias0_3 : std_logic_vector(31 downto 0) := "10111000011000101000110001001101";
CONSTANT W0_3_0 : std_logic_vector(31 downto 0) := "00111110110100110000010000001101";
CONSTANT W0_3_1 : std_logic_vector(31 downto 0) := "00111110011011111111110111010010";
CONSTANT W0_3_2 : std_logic_vector(31 downto 0) := "10111110111110111000011011010111";
CONSTANT W0_3_3 : std_logic_vector(31 downto 0) := "00111110100000000010110001000000";
CONSTANT W0_3_4 : std_logic_vector(31 downto 0) := "10111110111011000101111000110101";
CONSTANT W0_3_5 : std_logic_vector(31 downto 0) := "10111111000000110110011110010100";
CONSTANT W0_3_6 : std_logic_vector(31 downto 0) := "00111110100101100001010001110101";
CONSTANT W0_3_7 : std_logic_vector(31 downto 0) := "10111110100001100101001000100000";
SIGNAL rmul0_3_0, rmul0_3_1, rmul0_3_2, rmul0_3_3, rmul0_3_4, rmul0_3_5, rmul0_3_6, rmul0_3_7 : std_logic_vector(31 downto 0); -- Multiplication
SIGNAL go_mul0_3_0, done_mul0_3_0, go_mul0_3_1, done_mul0_3_1, go_mul0_3_2, done_mul0_3_2, go_mul0_3_3, done_mul0_3_3, go_mul0_3_4, done_mul0_3_4, go_mul0_3_5, done_mul0_3_5, go_mul0_3_6, done_mul0_3_6, go_mul0_3_7, done_mul0_3_7 : std_logic;
SIGNAL A0_3, B0_3, radd0_3 : std_logic_vector(31 downto 0); -- Addition
SIGNAL go_add0_3, done_add0_3 : std_logic;
SIGNAL iaf0_3, result0_3 : std_logic_vector(31 downto 0); -- Activation function
SIGNAL go_af0_3, done_af0_3 : std_logic;
-- neuron 4 --
CONSTANT bias0_4 : std_logic_vector(31 downto 0) := "10111000111011100001010101100001";
CONSTANT W0_4_0 : std_logic_vector(31 downto 0) := "10111101100100011010011010011111";
CONSTANT W0_4_1 : std_logic_vector(31 downto 0) := "10111110110110110100101001100010";
CONSTANT W0_4_2 : std_logic_vector(31 downto 0) := "00111101110001110101011011001100";
CONSTANT W0_4_3 : std_logic_vector(31 downto 0) := "10111110101110110000010010011010";
CONSTANT W0_4_4 : std_logic_vector(31 downto 0) := "10111111000110101111001001000001";
CONSTANT W0_4_5 : std_logic_vector(31 downto 0) := "00111110011011111000111000100101";
CONSTANT W0_4_6 : std_logic_vector(31 downto 0) := "10111101111001001100001111110011";
CONSTANT W0_4_7 : std_logic_vector(31 downto 0) := "10111011111000011000100010000110";
SIGNAL rmul0_4_0, rmul0_4_1, rmul0_4_2, rmul0_4_3, rmul0_4_4, rmul0_4_5, rmul0_4_6, rmul0_4_7 : std_logic_vector(31 downto 0); -- Multiplication
SIGNAL go_mul0_4_0, done_mul0_4_0, go_mul0_4_1, done_mul0_4_1, go_mul0_4_2, done_mul0_4_2, go_mul0_4_3, done_mul0_4_3, go_mul0_4_4, done_mul0_4_4, go_mul0_4_5, done_mul0_4_5, go_mul0_4_6, done_mul0_4_6, go_mul0_4_7, done_mul0_4_7 : std_logic;
SIGNAL A0_4, B0_4, radd0_4 : std_logic_vector(31 downto 0); -- Addition
SIGNAL go_add0_4, done_add0_4 : std_logic;
SIGNAL iaf0_4, result0_4 : std_logic_vector(31 downto 0); -- Activation function
SIGNAL go_af0_4, done_af0_4 : std_logic;
-- neuron 5 --
CONSTANT bias0_5 : std_logic_vector(31 downto 0) := "00111001110010110110111000001111";
CONSTANT W0_5_0 : std_logic_vector(31 downto 0) := "00111101100110111100010001111001";
CONSTANT W0_5_1 : std_logic_vector(31 downto 0) := "00111110101000110011101110010100";
CONSTANT W0_5_2 : std_logic_vector(31 downto 0) := "10111110111111101110000000110110";
CONSTANT W0_5_3 : std_logic_vector(31 downto 0) := "10111110101101010100010001110110";
CONSTANT W0_5_4 : std_logic_vector(31 downto 0) := "10111110100001101010111010100001";
CONSTANT W0_5_5 : std_logic_vector(31 downto 0) := "10111111000011100001000100010100";
CONSTANT W0_5_6 : std_logic_vector(31 downto 0) := "00111101101001011010001111000010";
CONSTANT W0_5_7 : std_logic_vector(31 downto 0) := "00111110111011100010000100110001";
SIGNAL rmul0_5_0, rmul0_5_1, rmul0_5_2, rmul0_5_3, rmul0_5_4, rmul0_5_5, rmul0_5_6, rmul0_5_7 : std_logic_vector(31 downto 0); -- Multiplication
SIGNAL go_mul0_5_0, done_mul0_5_0, go_mul0_5_1, done_mul0_5_1, go_mul0_5_2, done_mul0_5_2, go_mul0_5_3, done_mul0_5_3, go_mul0_5_4, done_mul0_5_4, go_mul0_5_5, done_mul0_5_5, go_mul0_5_6, done_mul0_5_6, go_mul0_5_7, done_mul0_5_7 : std_logic;
SIGNAL A0_5, B0_5, radd0_5 : std_logic_vector(31 downto 0); -- Addition
SIGNAL go_add0_5, done_add0_5 : std_logic;
SIGNAL iaf0_5, result0_5 : std_logic_vector(31 downto 0); -- Activation function
SIGNAL go_af0_5, done_af0_5 : std_logic;
-- neuron 6 --
CONSTANT bias0_6 : std_logic_vector(31 downto 0) := "00111010100111011110010010010010";
CONSTANT W0_6_0 : std_logic_vector(31 downto 0) := "10111110111001110010010110101011";
CONSTANT W0_6_1 : std_logic_vector(31 downto 0) := "00111110110101101010100011111010";
CONSTANT W0_6_2 : std_logic_vector(31 downto 0) := "00111110010000101110111101010110";
CONSTANT W0_6_3 : std_logic_vector(31 downto 0) := "00111110000011010010101000000101";
CONSTANT W0_6_4 : std_logic_vector(31 downto 0) := "10111110111011010101011001011110";
CONSTANT W0_6_5 : std_logic_vector(31 downto 0) := "10111101100001110011010011111011";
CONSTANT W0_6_6 : std_logic_vector(31 downto 0) := "00111101101100001011000000100010";
CONSTANT W0_6_7 : std_logic_vector(31 downto 0) := "10111111000001001101110000010100";
SIGNAL rmul0_6_0, rmul0_6_1, rmul0_6_2, rmul0_6_3, rmul0_6_4, rmul0_6_5, rmul0_6_6, rmul0_6_7 : std_logic_vector(31 downto 0); -- Multiplication
SIGNAL go_mul0_6_0, done_mul0_6_0, go_mul0_6_1, done_mul0_6_1, go_mul0_6_2, done_mul0_6_2, go_mul0_6_3, done_mul0_6_3, go_mul0_6_4, done_mul0_6_4, go_mul0_6_5, done_mul0_6_5, go_mul0_6_6, done_mul0_6_6, go_mul0_6_7, done_mul0_6_7 : std_logic;
SIGNAL A0_6, B0_6, radd0_6 : std_logic_vector(31 downto 0); -- Addition
SIGNAL go_add0_6, done_add0_6 : std_logic;
SIGNAL iaf0_6, result0_6 : std_logic_vector(31 downto 0); -- Activation function
SIGNAL go_af0_6, done_af0_6 : std_logic;
-- neuron 7 --
CONSTANT bias0_7 : std_logic_vector(31 downto 0) := "00111000101011111000001111001111";
CONSTANT W0_7_0 : std_logic_vector(31 downto 0) := "00111111000011011100001101100001";
CONSTANT W0_7_1 : std_logic_vector(31 downto 0) := "10111101011011100010010000010110";
CONSTANT W0_7_2 : std_logic_vector(31 downto 0) := "00111110100010100000111111111100";
CONSTANT W0_7_3 : std_logic_vector(31 downto 0) := "00111111000100101010111101011111";
CONSTANT W0_7_4 : std_logic_vector(31 downto 0) := "00111111000011101110001110010011";
CONSTANT W0_7_5 : std_logic_vector(31 downto 0) := "10111110000110101101110001010101";
CONSTANT W0_7_6 : std_logic_vector(31 downto 0) := "10111111000110101010111111001010";
CONSTANT W0_7_7 : std_logic_vector(31 downto 0) := "10111101001011101101010110110011";
SIGNAL rmul0_7_0, rmul0_7_1, rmul0_7_2, rmul0_7_3, rmul0_7_4, rmul0_7_5, rmul0_7_6, rmul0_7_7 : std_logic_vector(31 downto 0); -- Multiplication
SIGNAL go_mul0_7_0, done_mul0_7_0, go_mul0_7_1, done_mul0_7_1, go_mul0_7_2, done_mul0_7_2, go_mul0_7_3, done_mul0_7_3, go_mul0_7_4, done_mul0_7_4, go_mul0_7_5, done_mul0_7_5, go_mul0_7_6, done_mul0_7_6, go_mul0_7_7, done_mul0_7_7 : std_logic;
SIGNAL A0_7, B0_7, radd0_7 : std_logic_vector(31 downto 0); -- Addition
SIGNAL go_add0_7, done_add0_7 : std_logic;
SIGNAL iaf0_7, result0_7 : std_logic_vector(31 downto 0); -- Activation function
SIGNAL go_af0_7, done_af0_7 : std_logic;

--- Layer 1 ---
-- neuron 0 --
CONSTANT bias1_0 : std_logic_vector(31 downto 0) := "10111100010111000100110110010000";
CONSTANT W1_0_0 : std_logic_vector(31 downto 0) := "00111110011000110100100110101111";
CONSTANT W1_0_1 : std_logic_vector(31 downto 0) := "00111101001111101001001111011010";
CONSTANT W1_0_2 : std_logic_vector(31 downto 0) := "10111111000011101001011100010000";
CONSTANT W1_0_3 : std_logic_vector(31 downto 0) := "00111110100111001001101111000101";
CONSTANT W1_0_4 : std_logic_vector(31 downto 0) := "10111111001010010000001000111110";
CONSTANT W1_0_5 : std_logic_vector(31 downto 0) := "10111111000001001010011001110001";
CONSTANT W1_0_6 : std_logic_vector(31 downto 0) := "10111111000010110110001100011011";
CONSTANT W1_0_7 : std_logic_vector(31 downto 0) := "00111111000100110100111111011011";
SIGNAL rmul1_0_0, rmul1_0_1, rmul1_0_2, rmul1_0_3, rmul1_0_4, rmul1_0_5, rmul1_0_6, rmul1_0_7 : std_logic_vector(31 downto 0); -- Multiplication
SIGNAL go_mul1_0_0, done_mul1_0_0, go_mul1_0_1, done_mul1_0_1, go_mul1_0_2, done_mul1_0_2, go_mul1_0_3, done_mul1_0_3, go_mul1_0_4, done_mul1_0_4, go_mul1_0_5, done_mul1_0_5, go_mul1_0_6, done_mul1_0_6, go_mul1_0_7, done_mul1_0_7 : std_logic;
SIGNAL A1_0, B1_0, radd1_0 : std_logic_vector(31 downto 0); -- Addition
SIGNAL go_add1_0, done_add1_0 : std_logic;
SIGNAL iaf1_0, result1_0 : std_logic_vector(31 downto 0); -- Activation function
SIGNAL go_af1_0, done_af1_0 : std_logic;
-- neuron 1 --
CONSTANT bias1_1 : std_logic_vector(31 downto 0) := "10111011001110100100100000101111";
CONSTANT W1_1_0 : std_logic_vector(31 downto 0) := "00111110001101011101000011010011";
CONSTANT W1_1_1 : std_logic_vector(31 downto 0) := "10111110111101111111111110010010";
CONSTANT W1_1_2 : std_logic_vector(31 downto 0) := "00111110000001000111010011101010";
CONSTANT W1_1_3 : std_logic_vector(31 downto 0) := "00111110001101101101010101101111";
CONSTANT W1_1_4 : std_logic_vector(31 downto 0) := "10111111001001110011010100000010";
CONSTANT W1_1_5 : std_logic_vector(31 downto 0) := "10111110110111100000101101010111";
CONSTANT W1_1_6 : std_logic_vector(31 downto 0) := "00111110101110101011111001011011";
CONSTANT W1_1_7 : std_logic_vector(31 downto 0) := "10111101111001001001110111111000";
SIGNAL rmul1_1_0, rmul1_1_1, rmul1_1_2, rmul1_1_3, rmul1_1_4, rmul1_1_5, rmul1_1_6, rmul1_1_7 : std_logic_vector(31 downto 0); -- Multiplication
SIGNAL go_mul1_1_0, done_mul1_1_0, go_mul1_1_1, done_mul1_1_1, go_mul1_1_2, done_mul1_1_2, go_mul1_1_3, done_mul1_1_3, go_mul1_1_4, done_mul1_1_4, go_mul1_1_5, done_mul1_1_5, go_mul1_1_6, done_mul1_1_6, go_mul1_1_7, done_mul1_1_7 : std_logic;
SIGNAL A1_1, B1_1, radd1_1 : std_logic_vector(31 downto 0); -- Addition
SIGNAL go_add1_1, done_add1_1 : std_logic;
SIGNAL iaf1_1, result1_1 : std_logic_vector(31 downto 0); -- Activation function
SIGNAL go_af1_1, done_af1_1 : std_logic;
-- neuron 2 --
CONSTANT bias1_2 : std_logic_vector(31 downto 0) := "00111100010110011100110100101011";
CONSTANT W1_2_0 : std_logic_vector(31 downto 0) := "00111101110001110111110110000111";
CONSTANT W1_2_1 : std_logic_vector(31 downto 0) := "10111100110011100000110010001001";
CONSTANT W1_2_2 : std_logic_vector(31 downto 0) := "10111110010110010000010011001001";
CONSTANT W1_2_3 : std_logic_vector(31 downto 0) := "00111111000011000111001010000010";
CONSTANT W1_2_4 : std_logic_vector(31 downto 0) := "00111110100100110011101111111100";
CONSTANT W1_2_5 : std_logic_vector(31 downto 0) := "10111110000101110010111001001010";
CONSTANT W1_2_6 : std_logic_vector(31 downto 0) := "00111110111111111000100110101000";
CONSTANT W1_2_7 : std_logic_vector(31 downto 0) := "00111101110100111110000111000011";
SIGNAL rmul1_2_0, rmul1_2_1, rmul1_2_2, rmul1_2_3, rmul1_2_4, rmul1_2_5, rmul1_2_6, rmul1_2_7 : std_logic_vector(31 downto 0); -- Multiplication
SIGNAL go_mul1_2_0, done_mul1_2_0, go_mul1_2_1, done_mul1_2_1, go_mul1_2_2, done_mul1_2_2, go_mul1_2_3, done_mul1_2_3, go_mul1_2_4, done_mul1_2_4, go_mul1_2_5, done_mul1_2_5, go_mul1_2_6, done_mul1_2_6, go_mul1_2_7, done_mul1_2_7 : std_logic;
SIGNAL A1_2, B1_2, radd1_2 : std_logic_vector(31 downto 0); -- Addition
SIGNAL go_add1_2, done_add1_2 : std_logic;
SIGNAL iaf1_2, result1_2 : std_logic_vector(31 downto 0); -- Activation function
SIGNAL go_af1_2, done_af1_2 : std_logic;
-- neuron 3 --
CONSTANT bias1_3 : std_logic_vector(31 downto 0) := "00111100101011001101110010101101";
CONSTANT W1_3_0 : std_logic_vector(31 downto 0) := "10111110001010001111100011111010";
CONSTANT W1_3_1 : std_logic_vector(31 downto 0) := "10111110110000010110001100001110";
CONSTANT W1_3_2 : std_logic_vector(31 downto 0) := "10111111001100001001110101001001";
CONSTANT W1_3_3 : std_logic_vector(31 downto 0) := "00111110100011101111000010000010";
CONSTANT W1_3_4 : std_logic_vector(31 downto 0) := "00111110100001011011010111111110";
CONSTANT W1_3_5 : std_logic_vector(31 downto 0) := "10111111001000001110101101000010";
CONSTANT W1_3_6 : std_logic_vector(31 downto 0) := "00111110001101011111111111110110";
CONSTANT W1_3_7 : std_logic_vector(31 downto 0) := "10111110001101001010110101011111";
SIGNAL rmul1_3_0, rmul1_3_1, rmul1_3_2, rmul1_3_3, rmul1_3_4, rmul1_3_5, rmul1_3_6, rmul1_3_7 : std_logic_vector(31 downto 0); -- Multiplication
SIGNAL go_mul1_3_0, done_mul1_3_0, go_mul1_3_1, done_mul1_3_1, go_mul1_3_2, done_mul1_3_2, go_mul1_3_3, done_mul1_3_3, go_mul1_3_4, done_mul1_3_4, go_mul1_3_5, done_mul1_3_5, go_mul1_3_6, done_mul1_3_6, go_mul1_3_7, done_mul1_3_7 : std_logic;
SIGNAL A1_3, B1_3, radd1_3 : std_logic_vector(31 downto 0); -- Addition
SIGNAL go_add1_3, done_add1_3 : std_logic;
SIGNAL iaf1_3, result1_3 : std_logic_vector(31 downto 0); -- Activation function
SIGNAL go_af1_3, done_af1_3 : std_logic;
-- neuron 4 --
CONSTANT bias1_4 : std_logic_vector(31 downto 0) := "00111100000111101110001101010100";
CONSTANT W1_4_0 : std_logic_vector(31 downto 0) := "00111101001100111111011111010001";
CONSTANT W1_4_1 : std_logic_vector(31 downto 0) := "00111110100000100011100010011110";
CONSTANT W1_4_2 : std_logic_vector(31 downto 0) := "00111111000011111101111000000010";
CONSTANT W1_4_3 : std_logic_vector(31 downto 0) := "00111101000100010111010100001011";
CONSTANT W1_4_4 : std_logic_vector(31 downto 0) := "00111111001010011010110110101010";
CONSTANT W1_4_5 : std_logic_vector(31 downto 0) := "10111110010010010110100101101000";
CONSTANT W1_4_6 : std_logic_vector(31 downto 0) := "10111110100111011111011010000010";
CONSTANT W1_4_7 : std_logic_vector(31 downto 0) := "00111111000101011011101101110101";
SIGNAL rmul1_4_0, rmul1_4_1, rmul1_4_2, rmul1_4_3, rmul1_4_4, rmul1_4_5, rmul1_4_6, rmul1_4_7 : std_logic_vector(31 downto 0); -- Multiplication
SIGNAL go_mul1_4_0, done_mul1_4_0, go_mul1_4_1, done_mul1_4_1, go_mul1_4_2, done_mul1_4_2, go_mul1_4_3, done_mul1_4_3, go_mul1_4_4, done_mul1_4_4, go_mul1_4_5, done_mul1_4_5, go_mul1_4_6, done_mul1_4_6, go_mul1_4_7, done_mul1_4_7 : std_logic;
SIGNAL A1_4, B1_4, radd1_4 : std_logic_vector(31 downto 0); -- Addition
SIGNAL go_add1_4, done_add1_4 : std_logic;
SIGNAL iaf1_4, result1_4 : std_logic_vector(31 downto 0); -- Activation function
SIGNAL go_af1_4, done_af1_4 : std_logic;

--- Layer 2 ---
-- neuron 0 --
CONSTANT bias2_0 : std_logic_vector(31 downto 0) := "10111101111111001110101111011111";
CONSTANT W2_0_0 : std_logic_vector(31 downto 0) := "00111110111110111000010110111000";
CONSTANT W2_0_1 : std_logic_vector(31 downto 0) := "00111101100111010101010110010110";
CONSTANT W2_0_2 : std_logic_vector(31 downto 0) := "10111111000101010110010110001100";
CONSTANT W2_0_3 : std_logic_vector(31 downto 0) := "10111111011001110011000101111000";
CONSTANT W2_0_4 : std_logic_vector(31 downto 0) := "10111110110111000000001000010001";
SIGNAL rmul2_0_0, rmul2_0_1, rmul2_0_2, rmul2_0_3, rmul2_0_4 : std_logic_vector(31 downto 0); -- Multiplication
SIGNAL go_mul2_0_0, done_mul2_0_0, go_mul2_0_1, done_mul2_0_1, go_mul2_0_2, done_mul2_0_2, go_mul2_0_3, done_mul2_0_3, go_mul2_0_4, done_mul2_0_4 : std_logic;
SIGNAL A2_0, B2_0, radd2_0 : std_logic_vector(31 downto 0); -- Addition
SIGNAL go_add2_0, done_add2_0 : std_logic;
SIGNAL iaf2_0, result2_0 : std_logic_vector(31 downto 0); -- Activation function
SIGNAL go_af2_0, done_af2_0 : std_logic;

BEGIN


    -- CHANGE FOR NEW INPUT --

    input0 <= "00000000000000000000000000000000"; -- 0.0
    input1 <= "00000000000000000000000000000000"; -- 0.0
    input2 <= "00000000000000000000000000000000"; -- 0.0
    input3 <= "00000000000000000000000000000000"; -- 0.0
    input4 <= "00000000000000000000000000000000"; -- 0.0
    input5 <= "00000000000000000000000000000000"; -- 0.0
    input6 <= "00000000000000000000000000000000"; -- 0.0
    input7 <= "00000000000000000000000000000000"; -- 0.0

    -- CHANGE ABOVE FOR NEW INPUT --


    -- Clock process definition
    clk_process: process
    begin
        clk <= '0';
        wait for CLK_period/2;
        clk <= '1';
        wait for CLK_period/2;
    end process;

    stim_proc: process
    begin
        reset <= '1';
        wait for CLK_period*2;
        reset <= '0';
        wait for CLK_period*20;
        wait;
    end process;

    --**********************************--
    --* INSTANTIATE ARITHMETICAL UNITS *--
    --**********************************--

    --- Layer 0 ---
    -- neuron 0 --
    umult0_0_0: FPP_MULT port map
    (   A        => input0,
        B        => W0_0_0,
        clk      => clk,
        reset    => reset,
        go       => go_mul0_0_0,
        done     => done_mul0_0_0,
        overflow => open,
        result   => rmul0_0_0 );

    umult0_0_1: FPP_MULT port map
    (   A        => input1,
        B        => W0_0_1,
        clk      => clk,
        reset    => reset,
        go       => go_mul0_0_1,
        done     => done_mul0_0_1,
        overflow => open,
        result   => rmul0_0_1 );

    umult0_0_2: FPP_MULT port map
    (   A        => input2,
        B        => W0_0_2,
        clk      => clk,
        reset    => reset,
        go       => go_mul0_0_2,
        done     => done_mul0_0_2,
        overflow => open,
        result   => rmul0_0_2 );

    umult0_0_3: FPP_MULT port map
    (   A        => input3,
        B        => W0_0_3,
        clk      => clk,
        reset    => reset,
        go       => go_mul0_0_3,
        done     => done_mul0_0_3,
        overflow => open,
        result   => rmul0_0_3 );

    umult0_0_4: FPP_MULT port map
    (   A        => input4,
        B        => W0_0_4,
        clk      => clk,
        reset    => reset,
        go       => go_mul0_0_4,
        done     => done_mul0_0_4,
        overflow => open,
        result   => rmul0_0_4 );

    umult0_0_5: FPP_MULT port map
    (   A        => input5,
        B        => W0_0_5,
        clk      => clk,
        reset    => reset,
        go       => go_mul0_0_5,
        done     => done_mul0_0_5,
        overflow => open,
        result   => rmul0_0_5 );

    umult0_0_6: FPP_MULT port map
    (   A        => input6,
        B        => W0_0_6,
        clk      => clk,
        reset    => reset,
        go       => go_mul0_0_6,
        done     => done_mul0_0_6,
        overflow => open,
        result   => rmul0_0_6 );

    umult0_0_7: FPP_MULT port map
    (   A        => input7,
        B        => W0_0_7,
        clk      => clk,
        reset    => reset,
        go       => go_mul0_0_7,
        done     => done_mul0_0_7,
        overflow => open,
        result   => rmul0_0_7 );

    uadd0_0: FPP_ADD_SUB port map
    (   A        => A0_0,
        B        => B0_0,
        clk      => clk,
        reset    => reset,
        go       => go_add0_0,
        done     => done_add0_0,
        result   => radd0_0 );

    af0_0: hard_sigmoid port map
    (   X        => radd0_0,
        clk      => clk,
        reset    => reset,
        go       => go_af0_0,
        done     => done_af0_0,
        result   => result0_0 );

    -- neuron 1 --
    umult0_1_0: FPP_MULT port map
    (   A        => input0,
        B        => W0_1_0,
        clk      => clk,
        reset    => reset,
        go       => go_mul0_1_0,
        done     => done_mul0_1_0,
        overflow => open,
        result   => rmul0_1_0 );

    umult0_1_1: FPP_MULT port map
    (   A        => input1,
        B        => W0_1_1,
        clk      => clk,
        reset    => reset,
        go       => go_mul0_1_1,
        done     => done_mul0_1_1,
        overflow => open,
        result   => rmul0_1_1 );

    umult0_1_2: FPP_MULT port map
    (   A        => input2,
        B        => W0_1_2,
        clk      => clk,
        reset    => reset,
        go       => go_mul0_1_2,
        done     => done_mul0_1_2,
        overflow => open,
        result   => rmul0_1_2 );

    umult0_1_3: FPP_MULT port map
    (   A        => input3,
        B        => W0_1_3,
        clk      => clk,
        reset    => reset,
        go       => go_mul0_1_3,
        done     => done_mul0_1_3,
        overflow => open,
        result   => rmul0_1_3 );

    umult0_1_4: FPP_MULT port map
    (   A        => input4,
        B        => W0_1_4,
        clk      => clk,
        reset    => reset,
        go       => go_mul0_1_4,
        done     => done_mul0_1_4,
        overflow => open,
        result   => rmul0_1_4 );

    umult0_1_5: FPP_MULT port map
    (   A        => input5,
        B        => W0_1_5,
        clk      => clk,
        reset    => reset,
        go       => go_mul0_1_5,
        done     => done_mul0_1_5,
        overflow => open,
        result   => rmul0_1_5 );

    umult0_1_6: FPP_MULT port map
    (   A        => input6,
        B        => W0_1_6,
        clk      => clk,
        reset    => reset,
        go       => go_mul0_1_6,
        done     => done_mul0_1_6,
        overflow => open,
        result   => rmul0_1_6 );

    umult0_1_7: FPP_MULT port map
    (   A        => input7,
        B        => W0_1_7,
        clk      => clk,
        reset    => reset,
        go       => go_mul0_1_7,
        done     => done_mul0_1_7,
        overflow => open,
        result   => rmul0_1_7 );

    uadd0_1: FPP_ADD_SUB port map
    (   A        => A0_1,
        B        => B0_1,
        clk      => clk,
        reset    => reset,
        go       => go_add0_1,
        done     => done_add0_1,
        result   => radd0_1 );

    af0_1: hard_sigmoid port map
    (   X        => radd0_1,
        clk      => clk,
        reset    => reset,
        go       => go_af0_1,
        done     => done_af0_1,
        result   => result0_1 );

    -- neuron 2 --
    umult0_2_0: FPP_MULT port map
    (   A        => input0,
        B        => W0_2_0,
        clk      => clk,
        reset    => reset,
        go       => go_mul0_2_0,
        done     => done_mul0_2_0,
        overflow => open,
        result   => rmul0_2_0 );

    umult0_2_1: FPP_MULT port map
    (   A        => input1,
        B        => W0_2_1,
        clk      => clk,
        reset    => reset,
        go       => go_mul0_2_1,
        done     => done_mul0_2_1,
        overflow => open,
        result   => rmul0_2_1 );

    umult0_2_2: FPP_MULT port map
    (   A        => input2,
        B        => W0_2_2,
        clk      => clk,
        reset    => reset,
        go       => go_mul0_2_2,
        done     => done_mul0_2_2,
        overflow => open,
        result   => rmul0_2_2 );

    umult0_2_3: FPP_MULT port map
    (   A        => input3,
        B        => W0_2_3,
        clk      => clk,
        reset    => reset,
        go       => go_mul0_2_3,
        done     => done_mul0_2_3,
        overflow => open,
        result   => rmul0_2_3 );

    umult0_2_4: FPP_MULT port map
    (   A        => input4,
        B        => W0_2_4,
        clk      => clk,
        reset    => reset,
        go       => go_mul0_2_4,
        done     => done_mul0_2_4,
        overflow => open,
        result   => rmul0_2_4 );

    umult0_2_5: FPP_MULT port map
    (   A        => input5,
        B        => W0_2_5,
        clk      => clk,
        reset    => reset,
        go       => go_mul0_2_5,
        done     => done_mul0_2_5,
        overflow => open,
        result   => rmul0_2_5 );

    umult0_2_6: FPP_MULT port map
    (   A        => input6,
        B        => W0_2_6,
        clk      => clk,
        reset    => reset,
        go       => go_mul0_2_6,
        done     => done_mul0_2_6,
        overflow => open,
        result   => rmul0_2_6 );

    umult0_2_7: FPP_MULT port map
    (   A        => input7,
        B        => W0_2_7,
        clk      => clk,
        reset    => reset,
        go       => go_mul0_2_7,
        done     => done_mul0_2_7,
        overflow => open,
        result   => rmul0_2_7 );

    uadd0_2: FPP_ADD_SUB port map
    (   A        => A0_2,
        B        => B0_2,
        clk      => clk,
        reset    => reset,
        go       => go_add0_2,
        done     => done_add0_2,
        result   => radd0_2 );

    af0_2: hard_sigmoid port map
    (   X        => radd0_2,
        clk      => clk,
        reset    => reset,
        go       => go_af0_2,
        done     => done_af0_2,
        result   => result0_2 );

    -- neuron 3 --
    umult0_3_0: FPP_MULT port map
    (   A        => input0,
        B        => W0_3_0,
        clk      => clk,
        reset    => reset,
        go       => go_mul0_3_0,
        done     => done_mul0_3_0,
        overflow => open,
        result   => rmul0_3_0 );

    umult0_3_1: FPP_MULT port map
    (   A        => input1,
        B        => W0_3_1,
        clk      => clk,
        reset    => reset,
        go       => go_mul0_3_1,
        done     => done_mul0_3_1,
        overflow => open,
        result   => rmul0_3_1 );

    umult0_3_2: FPP_MULT port map
    (   A        => input2,
        B        => W0_3_2,
        clk      => clk,
        reset    => reset,
        go       => go_mul0_3_2,
        done     => done_mul0_3_2,
        overflow => open,
        result   => rmul0_3_2 );

    umult0_3_3: FPP_MULT port map
    (   A        => input3,
        B        => W0_3_3,
        clk      => clk,
        reset    => reset,
        go       => go_mul0_3_3,
        done     => done_mul0_3_3,
        overflow => open,
        result   => rmul0_3_3 );

    umult0_3_4: FPP_MULT port map
    (   A        => input4,
        B        => W0_3_4,
        clk      => clk,
        reset    => reset,
        go       => go_mul0_3_4,
        done     => done_mul0_3_4,
        overflow => open,
        result   => rmul0_3_4 );

    umult0_3_5: FPP_MULT port map
    (   A        => input5,
        B        => W0_3_5,
        clk      => clk,
        reset    => reset,
        go       => go_mul0_3_5,
        done     => done_mul0_3_5,
        overflow => open,
        result   => rmul0_3_5 );

    umult0_3_6: FPP_MULT port map
    (   A        => input6,
        B        => W0_3_6,
        clk      => clk,
        reset    => reset,
        go       => go_mul0_3_6,
        done     => done_mul0_3_6,
        overflow => open,
        result   => rmul0_3_6 );

    umult0_3_7: FPP_MULT port map
    (   A        => input7,
        B        => W0_3_7,
        clk      => clk,
        reset    => reset,
        go       => go_mul0_3_7,
        done     => done_mul0_3_7,
        overflow => open,
        result   => rmul0_3_7 );

    uadd0_3: FPP_ADD_SUB port map
    (   A        => A0_3,
        B        => B0_3,
        clk      => clk,
        reset    => reset,
        go       => go_add0_3,
        done     => done_add0_3,
        result   => radd0_3 );

    af0_3: hard_sigmoid port map
    (   X        => radd0_3,
        clk      => clk,
        reset    => reset,
        go       => go_af0_3,
        done     => done_af0_3,
        result   => result0_3 );

    -- neuron 4 --
    umult0_4_0: FPP_MULT port map
    (   A        => input0,
        B        => W0_4_0,
        clk      => clk,
        reset    => reset,
        go       => go_mul0_4_0,
        done     => done_mul0_4_0,
        overflow => open,
        result   => rmul0_4_0 );

    umult0_4_1: FPP_MULT port map
    (   A        => input1,
        B        => W0_4_1,
        clk      => clk,
        reset    => reset,
        go       => go_mul0_4_1,
        done     => done_mul0_4_1,
        overflow => open,
        result   => rmul0_4_1 );

    umult0_4_2: FPP_MULT port map
    (   A        => input2,
        B        => W0_4_2,
        clk      => clk,
        reset    => reset,
        go       => go_mul0_4_2,
        done     => done_mul0_4_2,
        overflow => open,
        result   => rmul0_4_2 );

    umult0_4_3: FPP_MULT port map
    (   A        => input3,
        B        => W0_4_3,
        clk      => clk,
        reset    => reset,
        go       => go_mul0_4_3,
        done     => done_mul0_4_3,
        overflow => open,
        result   => rmul0_4_3 );

    umult0_4_4: FPP_MULT port map
    (   A        => input4,
        B        => W0_4_4,
        clk      => clk,
        reset    => reset,
        go       => go_mul0_4_4,
        done     => done_mul0_4_4,
        overflow => open,
        result   => rmul0_4_4 );

    umult0_4_5: FPP_MULT port map
    (   A        => input5,
        B        => W0_4_5,
        clk      => clk,
        reset    => reset,
        go       => go_mul0_4_5,
        done     => done_mul0_4_5,
        overflow => open,
        result   => rmul0_4_5 );

    umult0_4_6: FPP_MULT port map
    (   A        => input6,
        B        => W0_4_6,
        clk      => clk,
        reset    => reset,
        go       => go_mul0_4_6,
        done     => done_mul0_4_6,
        overflow => open,
        result   => rmul0_4_6 );

    umult0_4_7: FPP_MULT port map
    (   A        => input7,
        B        => W0_4_7,
        clk      => clk,
        reset    => reset,
        go       => go_mul0_4_7,
        done     => done_mul0_4_7,
        overflow => open,
        result   => rmul0_4_7 );

    uadd0_4: FPP_ADD_SUB port map
    (   A        => A0_4,
        B        => B0_4,
        clk      => clk,
        reset    => reset,
        go       => go_add0_4,
        done     => done_add0_4,
        result   => radd0_4 );

    af0_4: hard_sigmoid port map
    (   X        => radd0_4,
        clk      => clk,
        reset    => reset,
        go       => go_af0_4,
        done     => done_af0_4,
        result   => result0_4 );

    -- neuron 5 --
    umult0_5_0: FPP_MULT port map
    (   A        => input0,
        B        => W0_5_0,
        clk      => clk,
        reset    => reset,
        go       => go_mul0_5_0,
        done     => done_mul0_5_0,
        overflow => open,
        result   => rmul0_5_0 );

    umult0_5_1: FPP_MULT port map
    (   A        => input1,
        B        => W0_5_1,
        clk      => clk,
        reset    => reset,
        go       => go_mul0_5_1,
        done     => done_mul0_5_1,
        overflow => open,
        result   => rmul0_5_1 );

    umult0_5_2: FPP_MULT port map
    (   A        => input2,
        B        => W0_5_2,
        clk      => clk,
        reset    => reset,
        go       => go_mul0_5_2,
        done     => done_mul0_5_2,
        overflow => open,
        result   => rmul0_5_2 );

    umult0_5_3: FPP_MULT port map
    (   A        => input3,
        B        => W0_5_3,
        clk      => clk,
        reset    => reset,
        go       => go_mul0_5_3,
        done     => done_mul0_5_3,
        overflow => open,
        result   => rmul0_5_3 );

    umult0_5_4: FPP_MULT port map
    (   A        => input4,
        B        => W0_5_4,
        clk      => clk,
        reset    => reset,
        go       => go_mul0_5_4,
        done     => done_mul0_5_4,
        overflow => open,
        result   => rmul0_5_4 );

    umult0_5_5: FPP_MULT port map
    (   A        => input5,
        B        => W0_5_5,
        clk      => clk,
        reset    => reset,
        go       => go_mul0_5_5,
        done     => done_mul0_5_5,
        overflow => open,
        result   => rmul0_5_5 );

    umult0_5_6: FPP_MULT port map
    (   A        => input6,
        B        => W0_5_6,
        clk      => clk,
        reset    => reset,
        go       => go_mul0_5_6,
        done     => done_mul0_5_6,
        overflow => open,
        result   => rmul0_5_6 );

    umult0_5_7: FPP_MULT port map
    (   A        => input7,
        B        => W0_5_7,
        clk      => clk,
        reset    => reset,
        go       => go_mul0_5_7,
        done     => done_mul0_5_7,
        overflow => open,
        result   => rmul0_5_7 );

    uadd0_5: FPP_ADD_SUB port map
    (   A        => A0_5,
        B        => B0_5,
        clk      => clk,
        reset    => reset,
        go       => go_add0_5,
        done     => done_add0_5,
        result   => radd0_5 );

    af0_5: hard_sigmoid port map
    (   X        => radd0_5,
        clk      => clk,
        reset    => reset,
        go       => go_af0_5,
        done     => done_af0_5,
        result   => result0_5 );

    -- neuron 6 --
    umult0_6_0: FPP_MULT port map
    (   A        => input0,
        B        => W0_6_0,
        clk      => clk,
        reset    => reset,
        go       => go_mul0_6_0,
        done     => done_mul0_6_0,
        overflow => open,
        result   => rmul0_6_0 );

    umult0_6_1: FPP_MULT port map
    (   A        => input1,
        B        => W0_6_1,
        clk      => clk,
        reset    => reset,
        go       => go_mul0_6_1,
        done     => done_mul0_6_1,
        overflow => open,
        result   => rmul0_6_1 );

    umult0_6_2: FPP_MULT port map
    (   A        => input2,
        B        => W0_6_2,
        clk      => clk,
        reset    => reset,
        go       => go_mul0_6_2,
        done     => done_mul0_6_2,
        overflow => open,
        result   => rmul0_6_2 );

    umult0_6_3: FPP_MULT port map
    (   A        => input3,
        B        => W0_6_3,
        clk      => clk,
        reset    => reset,
        go       => go_mul0_6_3,
        done     => done_mul0_6_3,
        overflow => open,
        result   => rmul0_6_3 );

    umult0_6_4: FPP_MULT port map
    (   A        => input4,
        B        => W0_6_4,
        clk      => clk,
        reset    => reset,
        go       => go_mul0_6_4,
        done     => done_mul0_6_4,
        overflow => open,
        result   => rmul0_6_4 );

    umult0_6_5: FPP_MULT port map
    (   A        => input5,
        B        => W0_6_5,
        clk      => clk,
        reset    => reset,
        go       => go_mul0_6_5,
        done     => done_mul0_6_5,
        overflow => open,
        result   => rmul0_6_5 );

    umult0_6_6: FPP_MULT port map
    (   A        => input6,
        B        => W0_6_6,
        clk      => clk,
        reset    => reset,
        go       => go_mul0_6_6,
        done     => done_mul0_6_6,
        overflow => open,
        result   => rmul0_6_6 );

    umult0_6_7: FPP_MULT port map
    (   A        => input7,
        B        => W0_6_7,
        clk      => clk,
        reset    => reset,
        go       => go_mul0_6_7,
        done     => done_mul0_6_7,
        overflow => open,
        result   => rmul0_6_7 );

    uadd0_6: FPP_ADD_SUB port map
    (   A        => A0_6,
        B        => B0_6,
        clk      => clk,
        reset    => reset,
        go       => go_add0_6,
        done     => done_add0_6,
        result   => radd0_6 );

    af0_6: hard_sigmoid port map
    (   X        => radd0_6,
        clk      => clk,
        reset    => reset,
        go       => go_af0_6,
        done     => done_af0_6,
        result   => result0_6 );

    -- neuron 7 --
    umult0_7_0: FPP_MULT port map
    (   A        => input0,
        B        => W0_7_0,
        clk      => clk,
        reset    => reset,
        go       => go_mul0_7_0,
        done     => done_mul0_7_0,
        overflow => open,
        result   => rmul0_7_0 );

    umult0_7_1: FPP_MULT port map
    (   A        => input1,
        B        => W0_7_1,
        clk      => clk,
        reset    => reset,
        go       => go_mul0_7_1,
        done     => done_mul0_7_1,
        overflow => open,
        result   => rmul0_7_1 );

    umult0_7_2: FPP_MULT port map
    (   A        => input2,
        B        => W0_7_2,
        clk      => clk,
        reset    => reset,
        go       => go_mul0_7_2,
        done     => done_mul0_7_2,
        overflow => open,
        result   => rmul0_7_2 );

    umult0_7_3: FPP_MULT port map
    (   A        => input3,
        B        => W0_7_3,
        clk      => clk,
        reset    => reset,
        go       => go_mul0_7_3,
        done     => done_mul0_7_3,
        overflow => open,
        result   => rmul0_7_3 );

    umult0_7_4: FPP_MULT port map
    (   A        => input4,
        B        => W0_7_4,
        clk      => clk,
        reset    => reset,
        go       => go_mul0_7_4,
        done     => done_mul0_7_4,
        overflow => open,
        result   => rmul0_7_4 );

    umult0_7_5: FPP_MULT port map
    (   A        => input5,
        B        => W0_7_5,
        clk      => clk,
        reset    => reset,
        go       => go_mul0_7_5,
        done     => done_mul0_7_5,
        overflow => open,
        result   => rmul0_7_5 );

    umult0_7_6: FPP_MULT port map
    (   A        => input6,
        B        => W0_7_6,
        clk      => clk,
        reset    => reset,
        go       => go_mul0_7_6,
        done     => done_mul0_7_6,
        overflow => open,
        result   => rmul0_7_6 );

    umult0_7_7: FPP_MULT port map
    (   A        => input7,
        B        => W0_7_7,
        clk      => clk,
        reset    => reset,
        go       => go_mul0_7_7,
        done     => done_mul0_7_7,
        overflow => open,
        result   => rmul0_7_7 );

    uadd0_7: FPP_ADD_SUB port map
    (   A        => A0_7,
        B        => B0_7,
        clk      => clk,
        reset    => reset,
        go       => go_add0_7,
        done     => done_add0_7,
        result   => radd0_7 );

    af0_7: hard_sigmoid port map
    (   X        => radd0_7,
        clk      => clk,
        reset    => reset,
        go       => go_af0_7,
        done     => done_af0_7,
        result   => result0_7 );


    --- Layer 1 ---
    -- neuron 0 --
    umult1_0_0: FPP_MULT port map
    (   A        => result0_0,
        B        => W1_0_0,
        clk      => clk,
        reset    => reset,
        go       => go_mul1_0_0,
        done     => done_mul1_0_0,
        overflow => open,
        result   => rmul1_0_0 );

    umult1_0_1: FPP_MULT port map
    (   A        => result0_1,
        B        => W1_0_1,
        clk      => clk,
        reset    => reset,
        go       => go_mul1_0_1,
        done     => done_mul1_0_1,
        overflow => open,
        result   => rmul1_0_1 );

    umult1_0_2: FPP_MULT port map
    (   A        => result0_2,
        B        => W1_0_2,
        clk      => clk,
        reset    => reset,
        go       => go_mul1_0_2,
        done     => done_mul1_0_2,
        overflow => open,
        result   => rmul1_0_2 );

    umult1_0_3: FPP_MULT port map
    (   A        => result0_3,
        B        => W1_0_3,
        clk      => clk,
        reset    => reset,
        go       => go_mul1_0_3,
        done     => done_mul1_0_3,
        overflow => open,
        result   => rmul1_0_3 );

    umult1_0_4: FPP_MULT port map
    (   A        => result0_4,
        B        => W1_0_4,
        clk      => clk,
        reset    => reset,
        go       => go_mul1_0_4,
        done     => done_mul1_0_4,
        overflow => open,
        result   => rmul1_0_4 );

    umult1_0_5: FPP_MULT port map
    (   A        => result0_5,
        B        => W1_0_5,
        clk      => clk,
        reset    => reset,
        go       => go_mul1_0_5,
        done     => done_mul1_0_5,
        overflow => open,
        result   => rmul1_0_5 );

    umult1_0_6: FPP_MULT port map
    (   A        => result0_6,
        B        => W1_0_6,
        clk      => clk,
        reset    => reset,
        go       => go_mul1_0_6,
        done     => done_mul1_0_6,
        overflow => open,
        result   => rmul1_0_6 );

    umult1_0_7: FPP_MULT port map
    (   A        => result0_7,
        B        => W1_0_7,
        clk      => clk,
        reset    => reset,
        go       => go_mul1_0_7,
        done     => done_mul1_0_7,
        overflow => open,
        result   => rmul1_0_7 );

    uadd1_0: FPP_ADD_SUB port map
    (   A        => A1_0,
        B        => B1_0,
        clk      => clk,
        reset    => reset,
        go       => go_add1_0,
        done     => done_add1_0,
        result   => radd1_0 );

    af1_0: hard_sigmoid port map
    (   X        => radd1_0,
        clk      => clk,
        reset    => reset,
        go       => go_af1_0,
        done     => done_af1_0,
        result   => result1_0 );

    -- neuron 1 --
    umult1_1_0: FPP_MULT port map
    (   A        => result0_0,
        B        => W1_1_0,
        clk      => clk,
        reset    => reset,
        go       => go_mul1_1_0,
        done     => done_mul1_1_0,
        overflow => open,
        result   => rmul1_1_0 );

    umult1_1_1: FPP_MULT port map
    (   A        => result0_1,
        B        => W1_1_1,
        clk      => clk,
        reset    => reset,
        go       => go_mul1_1_1,
        done     => done_mul1_1_1,
        overflow => open,
        result   => rmul1_1_1 );

    umult1_1_2: FPP_MULT port map
    (   A        => result0_2,
        B        => W1_1_2,
        clk      => clk,
        reset    => reset,
        go       => go_mul1_1_2,
        done     => done_mul1_1_2,
        overflow => open,
        result   => rmul1_1_2 );

    umult1_1_3: FPP_MULT port map
    (   A        => result0_3,
        B        => W1_1_3,
        clk      => clk,
        reset    => reset,
        go       => go_mul1_1_3,
        done     => done_mul1_1_3,
        overflow => open,
        result   => rmul1_1_3 );

    umult1_1_4: FPP_MULT port map
    (   A        => result0_4,
        B        => W1_1_4,
        clk      => clk,
        reset    => reset,
        go       => go_mul1_1_4,
        done     => done_mul1_1_4,
        overflow => open,
        result   => rmul1_1_4 );

    umult1_1_5: FPP_MULT port map
    (   A        => result0_5,
        B        => W1_1_5,
        clk      => clk,
        reset    => reset,
        go       => go_mul1_1_5,
        done     => done_mul1_1_5,
        overflow => open,
        result   => rmul1_1_5 );

    umult1_1_6: FPP_MULT port map
    (   A        => result0_6,
        B        => W1_1_6,
        clk      => clk,
        reset    => reset,
        go       => go_mul1_1_6,
        done     => done_mul1_1_6,
        overflow => open,
        result   => rmul1_1_6 );

    umult1_1_7: FPP_MULT port map
    (   A        => result0_7,
        B        => W1_1_7,
        clk      => clk,
        reset    => reset,
        go       => go_mul1_1_7,
        done     => done_mul1_1_7,
        overflow => open,
        result   => rmul1_1_7 );

    uadd1_1: FPP_ADD_SUB port map
    (   A        => A1_1,
        B        => B1_1,
        clk      => clk,
        reset    => reset,
        go       => go_add1_1,
        done     => done_add1_1,
        result   => radd1_1 );

    af1_1: hard_sigmoid port map
    (   X        => radd1_1,
        clk      => clk,
        reset    => reset,
        go       => go_af1_1,
        done     => done_af1_1,
        result   => result1_1 );

    -- neuron 2 --
    umult1_2_0: FPP_MULT port map
    (   A        => result0_0,
        B        => W1_2_0,
        clk      => clk,
        reset    => reset,
        go       => go_mul1_2_0,
        done     => done_mul1_2_0,
        overflow => open,
        result   => rmul1_2_0 );

    umult1_2_1: FPP_MULT port map
    (   A        => result0_1,
        B        => W1_2_1,
        clk      => clk,
        reset    => reset,
        go       => go_mul1_2_1,
        done     => done_mul1_2_1,
        overflow => open,
        result   => rmul1_2_1 );

    umult1_2_2: FPP_MULT port map
    (   A        => result0_2,
        B        => W1_2_2,
        clk      => clk,
        reset    => reset,
        go       => go_mul1_2_2,
        done     => done_mul1_2_2,
        overflow => open,
        result   => rmul1_2_2 );

    umult1_2_3: FPP_MULT port map
    (   A        => result0_3,
        B        => W1_2_3,
        clk      => clk,
        reset    => reset,
        go       => go_mul1_2_3,
        done     => done_mul1_2_3,
        overflow => open,
        result   => rmul1_2_3 );

    umult1_2_4: FPP_MULT port map
    (   A        => result0_4,
        B        => W1_2_4,
        clk      => clk,
        reset    => reset,
        go       => go_mul1_2_4,
        done     => done_mul1_2_4,
        overflow => open,
        result   => rmul1_2_4 );

    umult1_2_5: FPP_MULT port map
    (   A        => result0_5,
        B        => W1_2_5,
        clk      => clk,
        reset    => reset,
        go       => go_mul1_2_5,
        done     => done_mul1_2_5,
        overflow => open,
        result   => rmul1_2_5 );

    umult1_2_6: FPP_MULT port map
    (   A        => result0_6,
        B        => W1_2_6,
        clk      => clk,
        reset    => reset,
        go       => go_mul1_2_6,
        done     => done_mul1_2_6,
        overflow => open,
        result   => rmul1_2_6 );

    umult1_2_7: FPP_MULT port map
    (   A        => result0_7,
        B        => W1_2_7,
        clk      => clk,
        reset    => reset,
        go       => go_mul1_2_7,
        done     => done_mul1_2_7,
        overflow => open,
        result   => rmul1_2_7 );

    uadd1_2: FPP_ADD_SUB port map
    (   A        => A1_2,
        B        => B1_2,
        clk      => clk,
        reset    => reset,
        go       => go_add1_2,
        done     => done_add1_2,
        result   => radd1_2 );

    af1_2: hard_sigmoid port map
    (   X        => radd1_2,
        clk      => clk,
        reset    => reset,
        go       => go_af1_2,
        done     => done_af1_2,
        result   => result1_2 );

    -- neuron 3 --
    umult1_3_0: FPP_MULT port map
    (   A        => result0_0,
        B        => W1_3_0,
        clk      => clk,
        reset    => reset,
        go       => go_mul1_3_0,
        done     => done_mul1_3_0,
        overflow => open,
        result   => rmul1_3_0 );

    umult1_3_1: FPP_MULT port map
    (   A        => result0_1,
        B        => W1_3_1,
        clk      => clk,
        reset    => reset,
        go       => go_mul1_3_1,
        done     => done_mul1_3_1,
        overflow => open,
        result   => rmul1_3_1 );

    umult1_3_2: FPP_MULT port map
    (   A        => result0_2,
        B        => W1_3_2,
        clk      => clk,
        reset    => reset,
        go       => go_mul1_3_2,
        done     => done_mul1_3_2,
        overflow => open,
        result   => rmul1_3_2 );

    umult1_3_3: FPP_MULT port map
    (   A        => result0_3,
        B        => W1_3_3,
        clk      => clk,
        reset    => reset,
        go       => go_mul1_3_3,
        done     => done_mul1_3_3,
        overflow => open,
        result   => rmul1_3_3 );

    umult1_3_4: FPP_MULT port map
    (   A        => result0_4,
        B        => W1_3_4,
        clk      => clk,
        reset    => reset,
        go       => go_mul1_3_4,
        done     => done_mul1_3_4,
        overflow => open,
        result   => rmul1_3_4 );

    umult1_3_5: FPP_MULT port map
    (   A        => result0_5,
        B        => W1_3_5,
        clk      => clk,
        reset    => reset,
        go       => go_mul1_3_5,
        done     => done_mul1_3_5,
        overflow => open,
        result   => rmul1_3_5 );

    umult1_3_6: FPP_MULT port map
    (   A        => result0_6,
        B        => W1_3_6,
        clk      => clk,
        reset    => reset,
        go       => go_mul1_3_6,
        done     => done_mul1_3_6,
        overflow => open,
        result   => rmul1_3_6 );

    umult1_3_7: FPP_MULT port map
    (   A        => result0_7,
        B        => W1_3_7,
        clk      => clk,
        reset    => reset,
        go       => go_mul1_3_7,
        done     => done_mul1_3_7,
        overflow => open,
        result   => rmul1_3_7 );

    uadd1_3: FPP_ADD_SUB port map
    (   A        => A1_3,
        B        => B1_3,
        clk      => clk,
        reset    => reset,
        go       => go_add1_3,
        done     => done_add1_3,
        result   => radd1_3 );

    af1_3: hard_sigmoid port map
    (   X        => radd1_3,
        clk      => clk,
        reset    => reset,
        go       => go_af1_3,
        done     => done_af1_3,
        result   => result1_3 );

    -- neuron 4 --
    umult1_4_0: FPP_MULT port map
    (   A        => result0_0,
        B        => W1_4_0,
        clk      => clk,
        reset    => reset,
        go       => go_mul1_4_0,
        done     => done_mul1_4_0,
        overflow => open,
        result   => rmul1_4_0 );

    umult1_4_1: FPP_MULT port map
    (   A        => result0_1,
        B        => W1_4_1,
        clk      => clk,
        reset    => reset,
        go       => go_mul1_4_1,
        done     => done_mul1_4_1,
        overflow => open,
        result   => rmul1_4_1 );

    umult1_4_2: FPP_MULT port map
    (   A        => result0_2,
        B        => W1_4_2,
        clk      => clk,
        reset    => reset,
        go       => go_mul1_4_2,
        done     => done_mul1_4_2,
        overflow => open,
        result   => rmul1_4_2 );

    umult1_4_3: FPP_MULT port map
    (   A        => result0_3,
        B        => W1_4_3,
        clk      => clk,
        reset    => reset,
        go       => go_mul1_4_3,
        done     => done_mul1_4_3,
        overflow => open,
        result   => rmul1_4_3 );

    umult1_4_4: FPP_MULT port map
    (   A        => result0_4,
        B        => W1_4_4,
        clk      => clk,
        reset    => reset,
        go       => go_mul1_4_4,
        done     => done_mul1_4_4,
        overflow => open,
        result   => rmul1_4_4 );

    umult1_4_5: FPP_MULT port map
    (   A        => result0_5,
        B        => W1_4_5,
        clk      => clk,
        reset    => reset,
        go       => go_mul1_4_5,
        done     => done_mul1_4_5,
        overflow => open,
        result   => rmul1_4_5 );

    umult1_4_6: FPP_MULT port map
    (   A        => result0_6,
        B        => W1_4_6,
        clk      => clk,
        reset    => reset,
        go       => go_mul1_4_6,
        done     => done_mul1_4_6,
        overflow => open,
        result   => rmul1_4_6 );

    umult1_4_7: FPP_MULT port map
    (   A        => result0_7,
        B        => W1_4_7,
        clk      => clk,
        reset    => reset,
        go       => go_mul1_4_7,
        done     => done_mul1_4_7,
        overflow => open,
        result   => rmul1_4_7 );

    uadd1_4: FPP_ADD_SUB port map
    (   A        => A1_4,
        B        => B1_4,
        clk      => clk,
        reset    => reset,
        go       => go_add1_4,
        done     => done_add1_4,
        result   => radd1_4 );

    af1_4: hard_sigmoid port map
    (   X        => radd1_4,
        clk      => clk,
        reset    => reset,
        go       => go_af1_4,
        done     => done_af1_4,
        result   => result1_4 );


    --- Layer 2 ---
    -- neuron 0 --
    umult2_0_0: FPP_MULT port map
    (   A        => result1_0,
        B        => W2_0_0,
        clk      => clk,
        reset    => reset,
        go       => go_mul2_0_0,
        done     => done_mul2_0_0,
        overflow => open,
        result   => rmul2_0_0 );

    umult2_0_1: FPP_MULT port map
    (   A        => result1_1,
        B        => W2_0_1,
        clk      => clk,
        reset    => reset,
        go       => go_mul2_0_1,
        done     => done_mul2_0_1,
        overflow => open,
        result   => rmul2_0_1 );

    umult2_0_2: FPP_MULT port map
    (   A        => result1_2,
        B        => W2_0_2,
        clk      => clk,
        reset    => reset,
        go       => go_mul2_0_2,
        done     => done_mul2_0_2,
        overflow => open,
        result   => rmul2_0_2 );

    umult2_0_3: FPP_MULT port map
    (   A        => result1_3,
        B        => W2_0_3,
        clk      => clk,
        reset    => reset,
        go       => go_mul2_0_3,
        done     => done_mul2_0_3,
        overflow => open,
        result   => rmul2_0_3 );

    umult2_0_4: FPP_MULT port map
    (   A        => result1_4,
        B        => W2_0_4,
        clk      => clk,
        reset    => reset,
        go       => go_mul2_0_4,
        done     => done_mul2_0_4,
        overflow => open,
        result   => rmul2_0_4 );

    uadd2_0: FPP_ADD_SUB port map
    (   A        => A2_0,
        B        => B2_0,
        clk      => clk,
        reset    => reset,
        go       => go_add2_0,
        done     => done_add2_0,
        result   => radd2_0 );

    af2_0: hard_sigmoid port map
    (   X        => radd2_0,
        clk      => clk,
        reset    => reset,
        go       => go_af2_0,
        done     => done_af2_0,
        result   => result2_0 );

    --****************--
    --* MAIN PROCESS *--
    --****************--

    MAIN: process (clk, reset, state) is begin
    if reset = '1' then
        -- Initialization
        state <= NN_BEGIN;
        go_mul0_0_0 <= '0';
        go_mul0_0_1 <= '0';
        go_mul0_0_2 <= '0';
        go_mul0_0_3 <= '0';
        go_mul0_0_4 <= '0';
        go_mul0_0_5 <= '0';
        go_mul0_0_6 <= '0';
        go_mul0_0_7 <= '0';
        go_add0_0 <= '0';
        go_af0_0 <= '0';
        go_mul0_1_0 <= '0';
        go_mul0_1_1 <= '0';
        go_mul0_1_2 <= '0';
        go_mul0_1_3 <= '0';
        go_mul0_1_4 <= '0';
        go_mul0_1_5 <= '0';
        go_mul0_1_6 <= '0';
        go_mul0_1_7 <= '0';
        go_add0_1 <= '0';
        go_af0_1 <= '0';
        go_mul0_2_0 <= '0';
        go_mul0_2_1 <= '0';
        go_mul0_2_2 <= '0';
        go_mul0_2_3 <= '0';
        go_mul0_2_4 <= '0';
        go_mul0_2_5 <= '0';
        go_mul0_2_6 <= '0';
        go_mul0_2_7 <= '0';
        go_add0_2 <= '0';
        go_af0_2 <= '0';
        go_mul0_3_0 <= '0';
        go_mul0_3_1 <= '0';
        go_mul0_3_2 <= '0';
        go_mul0_3_3 <= '0';
        go_mul0_3_4 <= '0';
        go_mul0_3_5 <= '0';
        go_mul0_3_6 <= '0';
        go_mul0_3_7 <= '0';
        go_add0_3 <= '0';
        go_af0_3 <= '0';
        go_mul0_4_0 <= '0';
        go_mul0_4_1 <= '0';
        go_mul0_4_2 <= '0';
        go_mul0_4_3 <= '0';
        go_mul0_4_4 <= '0';
        go_mul0_4_5 <= '0';
        go_mul0_4_6 <= '0';
        go_mul0_4_7 <= '0';
        go_add0_4 <= '0';
        go_af0_4 <= '0';
        go_mul0_5_0 <= '0';
        go_mul0_5_1 <= '0';
        go_mul0_5_2 <= '0';
        go_mul0_5_3 <= '0';
        go_mul0_5_4 <= '0';
        go_mul0_5_5 <= '0';
        go_mul0_5_6 <= '0';
        go_mul0_5_7 <= '0';
        go_add0_5 <= '0';
        go_af0_5 <= '0';
        go_mul0_6_0 <= '0';
        go_mul0_6_1 <= '0';
        go_mul0_6_2 <= '0';
        go_mul0_6_3 <= '0';
        go_mul0_6_4 <= '0';
        go_mul0_6_5 <= '0';
        go_mul0_6_6 <= '0';
        go_mul0_6_7 <= '0';
        go_add0_6 <= '0';
        go_af0_6 <= '0';
        go_mul0_7_0 <= '0';
        go_mul0_7_1 <= '0';
        go_mul0_7_2 <= '0';
        go_mul0_7_3 <= '0';
        go_mul0_7_4 <= '0';
        go_mul0_7_5 <= '0';
        go_mul0_7_6 <= '0';
        go_mul0_7_7 <= '0';
        go_add0_7 <= '0';
        go_af0_7 <= '0';
        go_mul1_0_0 <= '0';
        go_mul1_0_1 <= '0';
        go_mul1_0_2 <= '0';
        go_mul1_0_3 <= '0';
        go_mul1_0_4 <= '0';
        go_mul1_0_5 <= '0';
        go_mul1_0_6 <= '0';
        go_mul1_0_7 <= '0';
        go_add1_0 <= '0';
        go_af1_0 <= '0';
        go_mul1_1_0 <= '0';
        go_mul1_1_1 <= '0';
        go_mul1_1_2 <= '0';
        go_mul1_1_3 <= '0';
        go_mul1_1_4 <= '0';
        go_mul1_1_5 <= '0';
        go_mul1_1_6 <= '0';
        go_mul1_1_7 <= '0';
        go_add1_1 <= '0';
        go_af1_1 <= '0';
        go_mul1_2_0 <= '0';
        go_mul1_2_1 <= '0';
        go_mul1_2_2 <= '0';
        go_mul1_2_3 <= '0';
        go_mul1_2_4 <= '0';
        go_mul1_2_5 <= '0';
        go_mul1_2_6 <= '0';
        go_mul1_2_7 <= '0';
        go_add1_2 <= '0';
        go_af1_2 <= '0';
        go_mul1_3_0 <= '0';
        go_mul1_3_1 <= '0';
        go_mul1_3_2 <= '0';
        go_mul1_3_3 <= '0';
        go_mul1_3_4 <= '0';
        go_mul1_3_5 <= '0';
        go_mul1_3_6 <= '0';
        go_mul1_3_7 <= '0';
        go_add1_3 <= '0';
        go_af1_3 <= '0';
        go_mul1_4_0 <= '0';
        go_mul1_4_1 <= '0';
        go_mul1_4_2 <= '0';
        go_mul1_4_3 <= '0';
        go_mul1_4_4 <= '0';
        go_mul1_4_5 <= '0';
        go_mul1_4_6 <= '0';
        go_mul1_4_7 <= '0';
        go_add1_4 <= '0';
        go_af1_4 <= '0';
        go_mul2_0_0 <= '0';
        go_mul2_0_1 <= '0';
        go_mul2_0_2 <= '0';
        go_mul2_0_3 <= '0';
        go_mul2_0_4 <= '0';
        go_add2_0 <= '0';
        go_af2_0 <= '0';
    elsif falling_edge(clk) then
        case state is
            when NN_BEGIN =>
                go_mul0_0_0 <= '1';
                go_mul0_0_1 <= '1';
                go_mul0_0_2 <= '1';
                go_mul0_0_3 <= '1';
                go_mul0_0_4 <= '1';
                go_mul0_0_5 <= '1';
                go_mul0_0_6 <= '1';
                go_mul0_0_7 <= '1';
                go_mul0_1_0 <= '1';
                go_mul0_1_1 <= '1';
                go_mul0_1_2 <= '1';
                go_mul0_1_3 <= '1';
                go_mul0_1_4 <= '1';
                go_mul0_1_5 <= '1';
                go_mul0_1_6 <= '1';
                go_mul0_1_7 <= '1';
                go_mul0_2_0 <= '1';
                go_mul0_2_1 <= '1';
                go_mul0_2_2 <= '1';
                go_mul0_2_3 <= '1';
                go_mul0_2_4 <= '1';
                go_mul0_2_5 <= '1';
                go_mul0_2_6 <= '1';
                go_mul0_2_7 <= '1';
                go_mul0_3_0 <= '1';
                go_mul0_3_1 <= '1';
                go_mul0_3_2 <= '1';
                go_mul0_3_3 <= '1';
                go_mul0_3_4 <= '1';
                go_mul0_3_5 <= '1';
                go_mul0_3_6 <= '1';
                go_mul0_3_7 <= '1';
                go_mul0_4_0 <= '1';
                go_mul0_4_1 <= '1';
                go_mul0_4_2 <= '1';
                go_mul0_4_3 <= '1';
                go_mul0_4_4 <= '1';
                go_mul0_4_5 <= '1';
                go_mul0_4_6 <= '1';
                go_mul0_4_7 <= '1';
                go_mul0_5_0 <= '1';
                go_mul0_5_1 <= '1';
                go_mul0_5_2 <= '1';
                go_mul0_5_3 <= '1';
                go_mul0_5_4 <= '1';
                go_mul0_5_5 <= '1';
                go_mul0_5_6 <= '1';
                go_mul0_5_7 <= '1';
                go_mul0_6_0 <= '1';
                go_mul0_6_1 <= '1';
                go_mul0_6_2 <= '1';
                go_mul0_6_3 <= '1';
                go_mul0_6_4 <= '1';
                go_mul0_6_5 <= '1';
                go_mul0_6_6 <= '1';
                go_mul0_6_7 <= '1';
                go_mul0_7_0 <= '1';
                go_mul0_7_1 <= '1';
                go_mul0_7_2 <= '1';
                go_mul0_7_3 <= '1';
                go_mul0_7_4 <= '1';
                go_mul0_7_5 <= '1';
                go_mul0_7_6 <= '1';
                go_mul0_7_7 <= '1';
                state <= LAYER0_MUL;
            ------
            when LAYER0_MUL =>
                if done_mul0_0_0 = '1' and done_mul0_0_1 = '1' and done_mul0_0_2 = '1' and done_mul0_0_3 = '1' and done_mul0_0_4 = '1' and done_mul0_0_5 = '1' and done_mul0_0_6 = '1' and done_mul0_0_7 = '1' and done_mul0_1_0 = '1' and done_mul0_1_1 = '1' and done_mul0_1_2 = '1' and done_mul0_1_3 = '1' and done_mul0_1_4 = '1' and done_mul0_1_5 = '1' and done_mul0_1_6 = '1' and done_mul0_1_7 = '1' and done_mul0_2_0 = '1' and done_mul0_2_1 = '1' and done_mul0_2_2 = '1' and done_mul0_2_3 = '1' and done_mul0_2_4 = '1' and done_mul0_2_5 = '1' and done_mul0_2_6 = '1' and done_mul0_2_7 = '1' and done_mul0_3_0 = '1' and done_mul0_3_1 = '1' and done_mul0_3_2 = '1' and done_mul0_3_3 = '1' and done_mul0_3_4 = '1' and done_mul0_3_5 = '1' and done_mul0_3_6 = '1' and done_mul0_3_7 = '1' and done_mul0_4_0 = '1' and done_mul0_4_1 = '1' and done_mul0_4_2 = '1' and done_mul0_4_3 = '1' and done_mul0_4_4 = '1' and done_mul0_4_5 = '1' and done_mul0_4_6 = '1' and done_mul0_4_7 = '1' and done_mul0_5_0 = '1' and done_mul0_5_1 = '1' and done_mul0_5_2 = '1' and done_mul0_5_3 = '1' and done_mul0_5_4 = '1' and done_mul0_5_5 = '1' and done_mul0_5_6 = '1' and done_mul0_5_7 = '1' and done_mul0_6_0 = '1' and done_mul0_6_1 = '1' and done_mul0_6_2 = '1' and done_mul0_6_3 = '1' and done_mul0_6_4 = '1' and done_mul0_6_5 = '1' and done_mul0_6_6 = '1' and done_mul0_6_7 = '1' and done_mul0_7_0 = '1' and done_mul0_7_1 = '1' and done_mul0_7_2 = '1' and done_mul0_7_3 = '1' and done_mul0_7_4 = '1' and done_mul0_7_5 = '1' and done_mul0_7_6 = '1' and done_mul0_7_7 = '1' then
                    go_mul0_0_0 <= '0';
                    go_mul0_0_1 <= '0';
                    go_mul0_0_2 <= '0';
                    go_mul0_0_3 <= '0';
                    go_mul0_0_4 <= '0';
                    go_mul0_0_5 <= '0';
                    go_mul0_0_6 <= '0';
                    go_mul0_0_7 <= '0';
                    go_mul0_1_0 <= '0';
                    go_mul0_1_1 <= '0';
                    go_mul0_1_2 <= '0';
                    go_mul0_1_3 <= '0';
                    go_mul0_1_4 <= '0';
                    go_mul0_1_5 <= '0';
                    go_mul0_1_6 <= '0';
                    go_mul0_1_7 <= '0';
                    go_mul0_2_0 <= '0';
                    go_mul0_2_1 <= '0';
                    go_mul0_2_2 <= '0';
                    go_mul0_2_3 <= '0';
                    go_mul0_2_4 <= '0';
                    go_mul0_2_5 <= '0';
                    go_mul0_2_6 <= '0';
                    go_mul0_2_7 <= '0';
                    go_mul0_3_0 <= '0';
                    go_mul0_3_1 <= '0';
                    go_mul0_3_2 <= '0';
                    go_mul0_3_3 <= '0';
                    go_mul0_3_4 <= '0';
                    go_mul0_3_5 <= '0';
                    go_mul0_3_6 <= '0';
                    go_mul0_3_7 <= '0';
                    go_mul0_4_0 <= '0';
                    go_mul0_4_1 <= '0';
                    go_mul0_4_2 <= '0';
                    go_mul0_4_3 <= '0';
                    go_mul0_4_4 <= '0';
                    go_mul0_4_5 <= '0';
                    go_mul0_4_6 <= '0';
                    go_mul0_4_7 <= '0';
                    go_mul0_5_0 <= '0';
                    go_mul0_5_1 <= '0';
                    go_mul0_5_2 <= '0';
                    go_mul0_5_3 <= '0';
                    go_mul0_5_4 <= '0';
                    go_mul0_5_5 <= '0';
                    go_mul0_5_6 <= '0';
                    go_mul0_5_7 <= '0';
                    go_mul0_6_0 <= '0';
                    go_mul0_6_1 <= '0';
                    go_mul0_6_2 <= '0';
                    go_mul0_6_3 <= '0';
                    go_mul0_6_4 <= '0';
                    go_mul0_6_5 <= '0';
                    go_mul0_6_6 <= '0';
                    go_mul0_6_7 <= '0';
                    go_mul0_7_0 <= '0';
                    go_mul0_7_1 <= '0';
                    go_mul0_7_2 <= '0';
                    go_mul0_7_3 <= '0';
                    go_mul0_7_4 <= '0';
                    go_mul0_7_5 <= '0';
                    go_mul0_7_6 <= '0';
                    go_mul0_7_7 <= '0';
                    A0_0 <= rmul0_0_0;
                    B0_0 <= rmul0_0_1;
                    go_add0_0 <= '1';
                    A0_1 <= rmul0_1_0;
                    B0_1 <= rmul0_1_1;
                    go_add0_1 <= '1';
                    A0_2 <= rmul0_2_0;
                    B0_2 <= rmul0_2_1;
                    go_add0_2 <= '1';
                    A0_3 <= rmul0_3_0;
                    B0_3 <= rmul0_3_1;
                    go_add0_3 <= '1';
                    A0_4 <= rmul0_4_0;
                    B0_4 <= rmul0_4_1;
                    go_add0_4 <= '1';
                    A0_5 <= rmul0_5_0;
                    B0_5 <= rmul0_5_1;
                    go_add0_5 <= '1';
                    A0_6 <= rmul0_6_0;
                    B0_6 <= rmul0_6_1;
                    go_add0_6 <= '1';
                    A0_7 <= rmul0_7_0;
                    B0_7 <= rmul0_7_1;
                    go_add0_7 <= '1';
                    state <= LAYER0_ADD0;
                end if;
            ------
            when LAYER0_ADD0 =>
                if done_add0_0 = '1' and done_add0_1 = '1' and done_add0_2 = '1' and done_add0_3 = '1' and done_add0_4 = '1' and done_add0_5 = '1' and done_add0_6 = '1' and done_add0_7 = '1' then
                    go_add0_0 <= '0';
                    go_add0_1 <= '0';
                    go_add0_2 <= '0';
                    go_add0_3 <= '0';
                    go_add0_4 <= '0';
                    go_add0_5 <= '0';
                    go_add0_6 <= '0';
                    go_add0_7 <= '0';
                    state <= LAYER0_ADD0ACK;
                end if;
            ------
            when LAYER0_ADD0ACK =>
                A0_0 <= radd0_0;
                B0_0 <= rmul0_0_2;
                go_add0_0 <= '1';
                A0_1 <= radd0_1;
                B0_1 <= rmul0_1_2;
                go_add0_1 <= '1';
                A0_2 <= radd0_2;
                B0_2 <= rmul0_2_2;
                go_add0_2 <= '1';
                A0_3 <= radd0_3;
                B0_3 <= rmul0_3_2;
                go_add0_3 <= '1';
                A0_4 <= radd0_4;
                B0_4 <= rmul0_4_2;
                go_add0_4 <= '1';
                A0_5 <= radd0_5;
                B0_5 <= rmul0_5_2;
                go_add0_5 <= '1';
                A0_6 <= radd0_6;
                B0_6 <= rmul0_6_2;
                go_add0_6 <= '1';
                A0_7 <= radd0_7;
                B0_7 <= rmul0_7_2;
                go_add0_7 <= '1';
                state <= LAYER0_ADD1;
            ------
            when LAYER0_ADD1 =>
                if done_add0_0 = '1' and done_add0_1 = '1' and done_add0_2 = '1' and done_add0_3 = '1' and done_add0_4 = '1' and done_add0_5 = '1' and done_add0_6 = '1' and done_add0_7 = '1' then
                    go_add0_0 <= '0';
                    go_add0_1 <= '0';
                    go_add0_2 <= '0';
                    go_add0_3 <= '0';
                    go_add0_4 <= '0';
                    go_add0_5 <= '0';
                    go_add0_6 <= '0';
                    go_add0_7 <= '0';
                    state <= LAYER0_ADD1ACK;
                end if;
            ------
            when LAYER0_ADD1ACK =>
                A0_0 <= radd0_0;
                B0_0 <= rmul0_0_3;
                go_add0_0 <= '1';
                A0_1 <= radd0_1;
                B0_1 <= rmul0_1_3;
                go_add0_1 <= '1';
                A0_2 <= radd0_2;
                B0_2 <= rmul0_2_3;
                go_add0_2 <= '1';
                A0_3 <= radd0_3;
                B0_3 <= rmul0_3_3;
                go_add0_3 <= '1';
                A0_4 <= radd0_4;
                B0_4 <= rmul0_4_3;
                go_add0_4 <= '1';
                A0_5 <= radd0_5;
                B0_5 <= rmul0_5_3;
                go_add0_5 <= '1';
                A0_6 <= radd0_6;
                B0_6 <= rmul0_6_3;
                go_add0_6 <= '1';
                A0_7 <= radd0_7;
                B0_7 <= rmul0_7_3;
                go_add0_7 <= '1';
                state <= LAYER0_ADD2;
            ------
            when LAYER0_ADD2 =>
                if done_add0_0 = '1' and done_add0_1 = '1' and done_add0_2 = '1' and done_add0_3 = '1' and done_add0_4 = '1' and done_add0_5 = '1' and done_add0_6 = '1' and done_add0_7 = '1' then
                    go_add0_0 <= '0';
                    go_add0_1 <= '0';
                    go_add0_2 <= '0';
                    go_add0_3 <= '0';
                    go_add0_4 <= '0';
                    go_add0_5 <= '0';
                    go_add0_6 <= '0';
                    go_add0_7 <= '0';
                    state <= LAYER0_ADD2ACK;
                end if;
            ------
            when LAYER0_ADD2ACK =>
                A0_0 <= radd0_0;
                B0_0 <= rmul0_0_4;
                go_add0_0 <= '1';
                A0_1 <= radd0_1;
                B0_1 <= rmul0_1_4;
                go_add0_1 <= '1';
                A0_2 <= radd0_2;
                B0_2 <= rmul0_2_4;
                go_add0_2 <= '1';
                A0_3 <= radd0_3;
                B0_3 <= rmul0_3_4;
                go_add0_3 <= '1';
                A0_4 <= radd0_4;
                B0_4 <= rmul0_4_4;
                go_add0_4 <= '1';
                A0_5 <= radd0_5;
                B0_5 <= rmul0_5_4;
                go_add0_5 <= '1';
                A0_6 <= radd0_6;
                B0_6 <= rmul0_6_4;
                go_add0_6 <= '1';
                A0_7 <= radd0_7;
                B0_7 <= rmul0_7_4;
                go_add0_7 <= '1';
                state <= LAYER0_ADD3;
            ------
            when LAYER0_ADD3 =>
                if done_add0_0 = '1' and done_add0_1 = '1' and done_add0_2 = '1' and done_add0_3 = '1' and done_add0_4 = '1' and done_add0_5 = '1' and done_add0_6 = '1' and done_add0_7 = '1' then
                    go_add0_0 <= '0';
                    go_add0_1 <= '0';
                    go_add0_2 <= '0';
                    go_add0_3 <= '0';
                    go_add0_4 <= '0';
                    go_add0_5 <= '0';
                    go_add0_6 <= '0';
                    go_add0_7 <= '0';
                    state <= LAYER0_ADD3ACK;
                end if;
            ------
            when LAYER0_ADD3ACK =>
                A0_0 <= radd0_0;
                B0_0 <= rmul0_0_5;
                go_add0_0 <= '1';
                A0_1 <= radd0_1;
                B0_1 <= rmul0_1_5;
                go_add0_1 <= '1';
                A0_2 <= radd0_2;
                B0_2 <= rmul0_2_5;
                go_add0_2 <= '1';
                A0_3 <= radd0_3;
                B0_3 <= rmul0_3_5;
                go_add0_3 <= '1';
                A0_4 <= radd0_4;
                B0_4 <= rmul0_4_5;
                go_add0_4 <= '1';
                A0_5 <= radd0_5;
                B0_5 <= rmul0_5_5;
                go_add0_5 <= '1';
                A0_6 <= radd0_6;
                B0_6 <= rmul0_6_5;
                go_add0_6 <= '1';
                A0_7 <= radd0_7;
                B0_7 <= rmul0_7_5;
                go_add0_7 <= '1';
                state <= LAYER0_ADD4;
            ------
            when LAYER0_ADD4 =>
                if done_add0_0 = '1' and done_add0_1 = '1' and done_add0_2 = '1' and done_add0_3 = '1' and done_add0_4 = '1' and done_add0_5 = '1' and done_add0_6 = '1' and done_add0_7 = '1' then
                    go_add0_0 <= '0';
                    go_add0_1 <= '0';
                    go_add0_2 <= '0';
                    go_add0_3 <= '0';
                    go_add0_4 <= '0';
                    go_add0_5 <= '0';
                    go_add0_6 <= '0';
                    go_add0_7 <= '0';
                    state <= LAYER0_ADD4ACK;
                end if;
            ------
            when LAYER0_ADD4ACK =>
                A0_0 <= radd0_0;
                B0_0 <= rmul0_0_6;
                go_add0_0 <= '1';
                A0_1 <= radd0_1;
                B0_1 <= rmul0_1_6;
                go_add0_1 <= '1';
                A0_2 <= radd0_2;
                B0_2 <= rmul0_2_6;
                go_add0_2 <= '1';
                A0_3 <= radd0_3;
                B0_3 <= rmul0_3_6;
                go_add0_3 <= '1';
                A0_4 <= radd0_4;
                B0_4 <= rmul0_4_6;
                go_add0_4 <= '1';
                A0_5 <= radd0_5;
                B0_5 <= rmul0_5_6;
                go_add0_5 <= '1';
                A0_6 <= radd0_6;
                B0_6 <= rmul0_6_6;
                go_add0_6 <= '1';
                A0_7 <= radd0_7;
                B0_7 <= rmul0_7_6;
                go_add0_7 <= '1';
                state <= LAYER0_ADD5;
            ------
            when LAYER0_ADD5 =>
                if done_add0_0 = '1' and done_add0_1 = '1' and done_add0_2 = '1' and done_add0_3 = '1' and done_add0_4 = '1' and done_add0_5 = '1' and done_add0_6 = '1' and done_add0_7 = '1' then
                    go_add0_0 <= '0';
                    go_add0_1 <= '0';
                    go_add0_2 <= '0';
                    go_add0_3 <= '0';
                    go_add0_4 <= '0';
                    go_add0_5 <= '0';
                    go_add0_6 <= '0';
                    go_add0_7 <= '0';
                    state <= LAYER0_ADD5ACK;
                end if;
            ------
            when LAYER0_ADD5ACK =>
                A0_0 <= radd0_0;
                B0_0 <= rmul0_0_7;
                go_add0_0 <= '1';
                A0_1 <= radd0_1;
                B0_1 <= rmul0_1_7;
                go_add0_1 <= '1';
                A0_2 <= radd0_2;
                B0_2 <= rmul0_2_7;
                go_add0_2 <= '1';
                A0_3 <= radd0_3;
                B0_3 <= rmul0_3_7;
                go_add0_3 <= '1';
                A0_4 <= radd0_4;
                B0_4 <= rmul0_4_7;
                go_add0_4 <= '1';
                A0_5 <= radd0_5;
                B0_5 <= rmul0_5_7;
                go_add0_5 <= '1';
                A0_6 <= radd0_6;
                B0_6 <= rmul0_6_7;
                go_add0_6 <= '1';
                A0_7 <= radd0_7;
                B0_7 <= rmul0_7_7;
                go_add0_7 <= '1';
                state <= LAYER0_ADD6;
            ------
            when LAYER0_ADD6 =>
                if done_add0_0 = '1' and done_add0_1 = '1' and done_add0_2 = '1' and done_add0_3 = '1' and done_add0_4 = '1' and done_add0_5 = '1' and done_add0_6 = '1' and done_add0_7 = '1' then
                    go_add0_0 <= '0';
                    go_add0_1 <= '0';
                    go_add0_2 <= '0';
                    go_add0_3 <= '0';
                    go_add0_4 <= '0';
                    go_add0_5 <= '0';
                    go_add0_6 <= '0';
                    go_add0_7 <= '0';
                    state <= LAYER0_ADD6ACK;
                end if;
            ------
            when LAYER0_ADD6ACK =>
                go_add0_0 <= '1';
                go_add0_1 <= '1';
                go_add0_2 <= '1';
                go_add0_3 <= '1';
                go_add0_4 <= '1';
                go_add0_5 <= '1';
                go_add0_6 <= '1';
                go_add0_7 <= '1';
                state <= LAYER0_ADDBIAS;
            ------
            when LAYER0_ADDBIAS =>
                if done_add0_0 = '1' and done_add0_1 = '1' and done_add0_2 = '1' and done_add0_3 = '1' and done_add0_4 = '1' and done_add0_5 = '1' and done_add0_6 = '1' and done_add0_7 = '1' then
                    go_add0_0 <= '0';
                    go_add0_1 <= '0';
                    go_add0_2 <= '0';
                    go_add0_3 <= '0';
                    go_add0_4 <= '0';
                    go_add0_5 <= '0';
                    go_add0_6 <= '0';
                    go_add0_7 <= '0';
                    go_af0_0 <= '1';
                    go_af0_1 <= '1';
                    go_af0_2 <= '1';
                    go_af0_3 <= '1';
                    go_af0_4 <= '1';
                    go_af0_5 <= '1';
                    go_af0_6 <= '1';
                    go_af0_7 <= '1';
                    state <= LAYER0_ACTFUNC;
                end if;
            ------
            when LAYER0_ACTFUNC =>
                if done_af0_0 = '1' and done_af0_1 = '1' and done_af0_2 = '1' and done_af0_3 = '1' and done_af0_4 = '1' and done_af0_5 = '1' and done_af0_6 = '1' and done_af0_7 = '1' then
                    go_af0_0 <= '0';
                    go_af0_1 <= '0';
                    go_af0_2 <= '0';
                    go_af0_3 <= '0';
                    go_af0_4 <= '0';
                    go_af0_5 <= '0';
                    go_af0_6 <= '0';
                    go_af0_7 <= '0';
                    go_mul1_0_0 <= '1';
                    go_mul1_0_1 <= '1';
                    go_mul1_0_2 <= '1';
                    go_mul1_0_3 <= '1';
                    go_mul1_0_4 <= '1';
                    go_mul1_0_5 <= '1';
                    go_mul1_0_6 <= '1';
                    go_mul1_0_7 <= '1';
                    go_mul1_1_0 <= '1';
                    go_mul1_1_1 <= '1';
                    go_mul1_1_2 <= '1';
                    go_mul1_1_3 <= '1';
                    go_mul1_1_4 <= '1';
                    go_mul1_1_5 <= '1';
                    go_mul1_1_6 <= '1';
                    go_mul1_1_7 <= '1';
                    go_mul1_2_0 <= '1';
                    go_mul1_2_1 <= '1';
                    go_mul1_2_2 <= '1';
                    go_mul1_2_3 <= '1';
                    go_mul1_2_4 <= '1';
                    go_mul1_2_5 <= '1';
                    go_mul1_2_6 <= '1';
                    go_mul1_2_7 <= '1';
                    go_mul1_3_0 <= '1';
                    go_mul1_3_1 <= '1';
                    go_mul1_3_2 <= '1';
                    go_mul1_3_3 <= '1';
                    go_mul1_3_4 <= '1';
                    go_mul1_3_5 <= '1';
                    go_mul1_3_6 <= '1';
                    go_mul1_3_7 <= '1';
                    go_mul1_4_0 <= '1';
                    go_mul1_4_1 <= '1';
                    go_mul1_4_2 <= '1';
                    go_mul1_4_3 <= '1';
                    go_mul1_4_4 <= '1';
                    go_mul1_4_5 <= '1';
                    go_mul1_4_6 <= '1';
                    go_mul1_4_7 <= '1';
                    state <= LAYER1_MUL;
                end if;
            ------
            when LAYER1_MUL =>
                if done_mul1_0_0 = '1' and done_mul1_0_1 = '1' and done_mul1_0_2 = '1' and done_mul1_0_3 = '1' and done_mul1_0_4 = '1' and done_mul1_0_5 = '1' and done_mul1_0_6 = '1' and done_mul1_0_7 = '1' and done_mul1_1_0 = '1' and done_mul1_1_1 = '1' and done_mul1_1_2 = '1' and done_mul1_1_3 = '1' and done_mul1_1_4 = '1' and done_mul1_1_5 = '1' and done_mul1_1_6 = '1' and done_mul1_1_7 = '1' and done_mul1_2_0 = '1' and done_mul1_2_1 = '1' and done_mul1_2_2 = '1' and done_mul1_2_3 = '1' and done_mul1_2_4 = '1' and done_mul1_2_5 = '1' and done_mul1_2_6 = '1' and done_mul1_2_7 = '1' and done_mul1_3_0 = '1' and done_mul1_3_1 = '1' and done_mul1_3_2 = '1' and done_mul1_3_3 = '1' and done_mul1_3_4 = '1' and done_mul1_3_5 = '1' and done_mul1_3_6 = '1' and done_mul1_3_7 = '1' and done_mul1_4_0 = '1' and done_mul1_4_1 = '1' and done_mul1_4_2 = '1' and done_mul1_4_3 = '1' and done_mul1_4_4 = '1' and done_mul1_4_5 = '1' and done_mul1_4_6 = '1' and done_mul1_4_7 = '1' then
                    go_mul1_0_0 <= '0';
                    go_mul1_0_1 <= '0';
                    go_mul1_0_2 <= '0';
                    go_mul1_0_3 <= '0';
                    go_mul1_0_4 <= '0';
                    go_mul1_0_5 <= '0';
                    go_mul1_0_6 <= '0';
                    go_mul1_0_7 <= '0';
                    go_mul1_1_0 <= '0';
                    go_mul1_1_1 <= '0';
                    go_mul1_1_2 <= '0';
                    go_mul1_1_3 <= '0';
                    go_mul1_1_4 <= '0';
                    go_mul1_1_5 <= '0';
                    go_mul1_1_6 <= '0';
                    go_mul1_1_7 <= '0';
                    go_mul1_2_0 <= '0';
                    go_mul1_2_1 <= '0';
                    go_mul1_2_2 <= '0';
                    go_mul1_2_3 <= '0';
                    go_mul1_2_4 <= '0';
                    go_mul1_2_5 <= '0';
                    go_mul1_2_6 <= '0';
                    go_mul1_2_7 <= '0';
                    go_mul1_3_0 <= '0';
                    go_mul1_3_1 <= '0';
                    go_mul1_3_2 <= '0';
                    go_mul1_3_3 <= '0';
                    go_mul1_3_4 <= '0';
                    go_mul1_3_5 <= '0';
                    go_mul1_3_6 <= '0';
                    go_mul1_3_7 <= '0';
                    go_mul1_4_0 <= '0';
                    go_mul1_4_1 <= '0';
                    go_mul1_4_2 <= '0';
                    go_mul1_4_3 <= '0';
                    go_mul1_4_4 <= '0';
                    go_mul1_4_5 <= '0';
                    go_mul1_4_6 <= '0';
                    go_mul1_4_7 <= '0';
                    A1_0 <= rmul1_0_0;
                    B1_0 <= rmul1_0_1;
                    go_add1_0 <= '1';
                    A1_1 <= rmul1_1_0;
                    B1_1 <= rmul1_1_1;
                    go_add1_1 <= '1';
                    A1_2 <= rmul1_2_0;
                    B1_2 <= rmul1_2_1;
                    go_add1_2 <= '1';
                    A1_3 <= rmul1_3_0;
                    B1_3 <= rmul1_3_1;
                    go_add1_3 <= '1';
                    A1_4 <= rmul1_4_0;
                    B1_4 <= rmul1_4_1;
                    go_add1_4 <= '1';
                    state <= LAYER1_ADD0;
                end if;
            ------
            when LAYER1_ADD0 =>
                if done_add1_0 = '1' and done_add1_1 = '1' and done_add1_2 = '1' and done_add1_3 = '1' and done_add1_4 = '1' then
                    go_add1_0 <= '0';
                    go_add1_1 <= '0';
                    go_add1_2 <= '0';
                    go_add1_3 <= '0';
                    go_add1_4 <= '0';
                    state <= LAYER1_ADD0ACK;
                end if;
            ------
            when LAYER1_ADD0ACK =>
                A1_0 <= radd1_0;
                B1_0 <= rmul1_0_2;
                go_add1_0 <= '1';
                A1_1 <= radd1_1;
                B1_1 <= rmul1_1_2;
                go_add1_1 <= '1';
                A1_2 <= radd1_2;
                B1_2 <= rmul1_2_2;
                go_add1_2 <= '1';
                A1_3 <= radd1_3;
                B1_3 <= rmul1_3_2;
                go_add1_3 <= '1';
                A1_4 <= radd1_4;
                B1_4 <= rmul1_4_2;
                go_add1_4 <= '1';
                state <= LAYER1_ADD1;
            ------
            when LAYER1_ADD1 =>
                if done_add1_0 = '1' and done_add1_1 = '1' and done_add1_2 = '1' and done_add1_3 = '1' and done_add1_4 = '1' then
                    go_add1_0 <= '0';
                    go_add1_1 <= '0';
                    go_add1_2 <= '0';
                    go_add1_3 <= '0';
                    go_add1_4 <= '0';
                    state <= LAYER1_ADD1ACK;
                end if;
            ------
            when LAYER1_ADD1ACK =>
                A1_0 <= radd1_0;
                B1_0 <= rmul1_0_3;
                go_add1_0 <= '1';
                A1_1 <= radd1_1;
                B1_1 <= rmul1_1_3;
                go_add1_1 <= '1';
                A1_2 <= radd1_2;
                B1_2 <= rmul1_2_3;
                go_add1_2 <= '1';
                A1_3 <= radd1_3;
                B1_3 <= rmul1_3_3;
                go_add1_3 <= '1';
                A1_4 <= radd1_4;
                B1_4 <= rmul1_4_3;
                go_add1_4 <= '1';
                state <= LAYER1_ADD2;
            ------
            when LAYER1_ADD2 =>
                if done_add1_0 = '1' and done_add1_1 = '1' and done_add1_2 = '1' and done_add1_3 = '1' and done_add1_4 = '1' then
                    go_add1_0 <= '0';
                    go_add1_1 <= '0';
                    go_add1_2 <= '0';
                    go_add1_3 <= '0';
                    go_add1_4 <= '0';
                    state <= LAYER1_ADD2ACK;
                end if;
            ------
            when LAYER1_ADD2ACK =>
                A1_0 <= radd1_0;
                B1_0 <= rmul1_0_4;
                go_add1_0 <= '1';
                A1_1 <= radd1_1;
                B1_1 <= rmul1_1_4;
                go_add1_1 <= '1';
                A1_2 <= radd1_2;
                B1_2 <= rmul1_2_4;
                go_add1_2 <= '1';
                A1_3 <= radd1_3;
                B1_3 <= rmul1_3_4;
                go_add1_3 <= '1';
                A1_4 <= radd1_4;
                B1_4 <= rmul1_4_4;
                go_add1_4 <= '1';
                state <= LAYER1_ADD3;
            ------
            when LAYER1_ADD3 =>
                if done_add1_0 = '1' and done_add1_1 = '1' and done_add1_2 = '1' and done_add1_3 = '1' and done_add1_4 = '1' then
                    go_add1_0 <= '0';
                    go_add1_1 <= '0';
                    go_add1_2 <= '0';
                    go_add1_3 <= '0';
                    go_add1_4 <= '0';
                    state <= LAYER1_ADD3ACK;
                end if;
            ------
            when LAYER1_ADD3ACK =>
                A1_0 <= radd1_0;
                B1_0 <= rmul1_0_5;
                go_add1_0 <= '1';
                A1_1 <= radd1_1;
                B1_1 <= rmul1_1_5;
                go_add1_1 <= '1';
                A1_2 <= radd1_2;
                B1_2 <= rmul1_2_5;
                go_add1_2 <= '1';
                A1_3 <= radd1_3;
                B1_3 <= rmul1_3_5;
                go_add1_3 <= '1';
                A1_4 <= radd1_4;
                B1_4 <= rmul1_4_5;
                go_add1_4 <= '1';
                state <= LAYER1_ADD4;
            ------
            when LAYER1_ADD4 =>
                if done_add1_0 = '1' and done_add1_1 = '1' and done_add1_2 = '1' and done_add1_3 = '1' and done_add1_4 = '1' then
                    go_add1_0 <= '0';
                    go_add1_1 <= '0';
                    go_add1_2 <= '0';
                    go_add1_3 <= '0';
                    go_add1_4 <= '0';
                    state <= LAYER1_ADD4ACK;
                end if;
            ------
            when LAYER1_ADD4ACK =>
                A1_0 <= radd1_0;
                B1_0 <= rmul1_0_6;
                go_add1_0 <= '1';
                A1_1 <= radd1_1;
                B1_1 <= rmul1_1_6;
                go_add1_1 <= '1';
                A1_2 <= radd1_2;
                B1_2 <= rmul1_2_6;
                go_add1_2 <= '1';
                A1_3 <= radd1_3;
                B1_3 <= rmul1_3_6;
                go_add1_3 <= '1';
                A1_4 <= radd1_4;
                B1_4 <= rmul1_4_6;
                go_add1_4 <= '1';
                state <= LAYER1_ADD5;
            ------
            when LAYER1_ADD5 =>
                if done_add1_0 = '1' and done_add1_1 = '1' and done_add1_2 = '1' and done_add1_3 = '1' and done_add1_4 = '1' then
                    go_add1_0 <= '0';
                    go_add1_1 <= '0';
                    go_add1_2 <= '0';
                    go_add1_3 <= '0';
                    go_add1_4 <= '0';
                    state <= LAYER1_ADD5ACK;
                end if;
            ------
            when LAYER1_ADD5ACK =>
                A1_0 <= radd1_0;
                B1_0 <= rmul1_0_7;
                go_add1_0 <= '1';
                A1_1 <= radd1_1;
                B1_1 <= rmul1_1_7;
                go_add1_1 <= '1';
                A1_2 <= radd1_2;
                B1_2 <= rmul1_2_7;
                go_add1_2 <= '1';
                A1_3 <= radd1_3;
                B1_3 <= rmul1_3_7;
                go_add1_3 <= '1';
                A1_4 <= radd1_4;
                B1_4 <= rmul1_4_7;
                go_add1_4 <= '1';
                state <= LAYER1_ADD6;
            ------
            when LAYER1_ADD6 =>
                if done_add1_0 = '1' and done_add1_1 = '1' and done_add1_2 = '1' and done_add1_3 = '1' and done_add1_4 = '1' then
                    go_add1_0 <= '0';
                    go_add1_1 <= '0';
                    go_add1_2 <= '0';
                    go_add1_3 <= '0';
                    go_add1_4 <= '0';
                    state <= LAYER1_ADD6ACK;
                end if;
            ------
            when LAYER1_ADD6ACK =>
                go_add1_0 <= '1';
                go_add1_1 <= '1';
                go_add1_2 <= '1';
                go_add1_3 <= '1';
                go_add1_4 <= '1';
                state <= LAYER1_ADDBIAS;
            ------
            when LAYER1_ADDBIAS =>
                if done_add1_0 = '1' and done_add1_1 = '1' and done_add1_2 = '1' and done_add1_3 = '1' and done_add1_4 = '1' then
                    go_add1_0 <= '0';
                    go_add1_1 <= '0';
                    go_add1_2 <= '0';
                    go_add1_3 <= '0';
                    go_add1_4 <= '0';
                    go_af1_0 <= '1';
                    go_af1_1 <= '1';
                    go_af1_2 <= '1';
                    go_af1_3 <= '1';
                    go_af1_4 <= '1';
                    state <= LAYER1_ACTFUNC;
                end if;
            ------
            when LAYER1_ACTFUNC =>
                if done_af1_0 = '1' and done_af1_1 = '1' and done_af1_2 = '1' and done_af1_3 = '1' and done_af1_4 = '1' then
                    go_af1_0 <= '0';
                    go_af1_1 <= '0';
                    go_af1_2 <= '0';
                    go_af1_3 <= '0';
                    go_af1_4 <= '0';
                    go_mul2_0_0 <= '1';
                    go_mul2_0_1 <= '1';
                    go_mul2_0_2 <= '1';
                    go_mul2_0_3 <= '1';
                    go_mul2_0_4 <= '1';
                    state <= LAYER2_MUL;
                end if;
            ------
            when LAYER2_MUL =>
                if done_mul2_0_0 = '1' and done_mul2_0_1 = '1' and done_mul2_0_2 = '1' and done_mul2_0_3 = '1' and done_mul2_0_4 = '1' then
                    go_mul2_0_0 <= '0';
                    go_mul2_0_1 <= '0';
                    go_mul2_0_2 <= '0';
                    go_mul2_0_3 <= '0';
                    go_mul2_0_4 <= '0';
                    A2_0 <= rmul2_0_0;
                    B2_0 <= rmul2_0_1;
                    go_add2_0 <= '1';
                    state <= LAYER2_ADD0;
                end if;
            ------
            when LAYER2_ADD0 =>
                if done_add2_0 = '1' then
                    go_add2_0 <= '0';
                    state <= LAYER2_ADD0ACK;
                end if;
            ------
            when LAYER2_ADD0ACK =>
                A2_0 <= radd2_0;
                B2_0 <= rmul2_0_2;
                go_add2_0 <= '1';
                state <= LAYER2_ADD1;
            ------
            when LAYER2_ADD1 =>
                if done_add2_0 = '1' then
                    go_add2_0 <= '0';
                    state <= LAYER2_ADD1ACK;
                end if;
            ------
            when LAYER2_ADD1ACK =>
                A2_0 <= radd2_0;
                B2_0 <= rmul2_0_3;
                go_add2_0 <= '1';
                state <= LAYER2_ADD2;
            ------
            when LAYER2_ADD2 =>
                if done_add2_0 = '1' then
                    go_add2_0 <= '0';
                    state <= LAYER2_ADD2ACK;
                end if;
            ------
            when LAYER2_ADD2ACK =>
                A2_0 <= radd2_0;
                B2_0 <= rmul2_0_4;
                go_add2_0 <= '1';
                state <= LAYER2_ADD3;
            ------
            when LAYER2_ADD3 =>
                if done_add2_0 = '1' then
                    go_add2_0 <= '0';
                    state <= LAYER2_ADD3ACK;
                end if;
            ------
            when LAYER2_ADD3ACK =>
                go_add2_0 <= '1';
                state <= LAYER2_ADDBIAS;
            ------
            when LAYER2_ADDBIAS =>
                if done_add2_0 = '1' then
                    go_add2_0 <= '0';
                    go_af2_0 <= '1';
                    state <= LAYER2_ACTFUNC;
                end if;
            ------
            when LAYER2_ACTFUNC =>
                if done_af2_0 = '1' then
                    go_af2_0 <= '0';
                    final_result0 <= result2_0;
                    state <= NN_END;
                end if;
            ------
            when NN_END =>
                state <= NN_END; --do nothing
	    end case;
    end if;
    end process;

END;
