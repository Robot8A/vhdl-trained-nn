import numpy
import bitstring
import datetime

__author__ = "Héctor Ochoa Ortiz"


def floatToBinary(n):
    """
    Returns the binary representation of a numpy float32 in IEEE 754 32-bit float standard
    """
    if not isinstance(n, numpy.float32):
        raise TypeError("n must be numpy.float32")
    return bitstring.BitArray(float=n, length=32).bin


def generate_states(input_dim: int, neurons: list):
    s = ["NN_BEGIN"]
    for l in range(len(neurons)):
        # For each layer
        s.append("LAYER" + str(l) + "_MUL")
        if l == 0:
            r = range(input_dim - 1)
        else:
            r = range(neurons[l-1] - 1)
        for n in r:
            # For each neuron in the previous layer - 1
            s.append("LAYER" + str(l) + "_ADD" + str(n))
            s.append("LAYER" + str(l) + "_ADD" + str(n) + "ACK")
        s.append("LAYER" + str(l) + "_ADDBIAS")
        s.append("LAYER" + str(l) + "_ACTFUNC")
    s.append("NN_END")
    return s


def create(input_dim: int, neurons: list, weights: dict):
    print("--Writing VHDL file--")
    with open("neuralNetwork.vhd", "w") as f:

        f.write("\n".join([
            "-- File: neuralNetwork.vhd",
            "-- Generated by: vhdl.py",
            "-- Author: Héctor Ochoa Ortiz",
            "-- Datetime: " + datetime.datetime.utcnow().isoformat() + "Z",
            "",
            "library IEEE;",
            "use IEEE.std_logic_1164.all;",
            "use IEEE.numeric_std.all;",
            "",
            "use work.FloatPt.all;",
            "use work.activationFunct.all;",
            "",
            "ENTITY neuralNetwork IS",
            "END neuralNetwork;",
            "",
            "ARCHITECTURE behavior OF neuralNetwork IS",
            "",
            "-- Clock period definitions",
            "constant CLK_period: time := 10 ns;",
            "",
            "--***********--",
            "--* SIGNALS *--",
            "--***********--",
            "",
            "SIGNAL clk, reset : std_logic;",
            "type NN_STATE is (" + ", ".join(generate_states(input_dim, neurons)) + ");",
            "signal state: NN_STATE;",
            "SIGNAL " + ", ".join(("input" + str(i)) for i in range(input_dim)) + " : std_logic_vector(31 downto 0); -- Input layer",
            "SIGNAL " + ",".join(("final_result" + str(i)) for i in range(neurons[len(neurons) - 1])) + " : std_logic_vector(31 downto 0);"
        ]))

        f.write("\n")

        for l in range(len(neurons)):
            # For each layer
            f.write("\n")
            f.write("--- Layer " + str(l) + " ---\n")
            if l == 0:
                r = range(input_dim)
            else:
                r = range(neurons[l - 1])

            for n in range(neurons[l]):
                # For each neuron in the layer
                f.write("-- neuron " + str(n) + " --\n")
                # Multiplication units signals
                s1 = []
                s32 = []

                f.write("CONSTANT bias" + str(l) + "_" + str(n) + " : std_logic_vector(31 downto 0) := \"" +
                        str(floatToBinary(weights[l]["b"][n])) + "\";\n")

                for pn in r:
                    # For each neuron in the previous layer
                    f.write("CONSTANT W" + str(l) + "_" + str(n) + "_" + str(pn) + " : std_logic_vector(31 downto 0) := \"" +
                            str(floatToBinary(weights[l]["w"][pn][n])) + "\";\n")
                    s1.append("go_mul" + str(l) + "_" + str(n) + "_" + str(pn))
                    s1.append("done_mul" + str(l) + "_" + str(n) + "_" + str(pn))
                    s32.append("rmul" + str(l) + "_" + str(n) + "_" + str(pn))

                f.write("SIGNAL " + ", ".join(s32) + " : std_logic_vector(31 downto 0); -- Multiplication\n"
                        "SIGNAL " + ", ".join(s1) + " : std_logic;\n")

                # Addition units signals
                s1 = ["go_add" + str(l) + "_" + str(n), "done_add" + str(l) + "_" + str(n)]
                s32 = ["A" + str(l) + "_" + str(n), "B" + str(l) + "_" + str(n), "radd" + str(l) + "_" + str(n)]
                f.write("SIGNAL " + ", ".join(s32) + " : std_logic_vector(31 downto 0); -- Addition\n"
                        "SIGNAL " + ", ".join(s1) + " : std_logic;\n")

                # Activation function units signals
                s1 = ["go_af" + str(l) + "_" + str(n), "done_af" + str(l) + "_" + str(n)]
                s32 = ["iaf" + str(l) + "_" + str(n), "result" + str(l) + "_" + str(n)]
                f.write("SIGNAL " + ", ".join(s32) + " : std_logic_vector(31 downto 0); -- Activation function\n"
                        "SIGNAL " + ", ".join(s1) + " : std_logic;\n")

        f.write('\n')
        f.write('BEGIN\n')
        f.write('\n')
        f.write('\n')
        f.write("    -- CHANGE FOR NEW INPUT --\n")
        f.write('\n')
        for i in range(input_dim):
            f.write("    input" + str(i) + " <= \"00000000000000000000000000000000\"; -- 0.0\n")
        f.write('\n')
        f.write("    -- CHANGE ABOVE FOR NEW INPUT --\n")
        f.write('\n')
        f.write('\n')

        f.write("\n".join([
            "    -- Clock process definition",
            "    clk_process: process",
            "    begin",
            "        clk <= '0';",
            "        wait for CLK_period/2;",
            "        clk <= '1';",
            "        wait for CLK_period/2;",
            "    end process;",
            "",
            "    stim_proc: process",
            "    begin",
            "        reset <= '1';",
            "        wait for CLK_period*2;",
            "        reset <= '0';",
            "        wait for CLK_period*20;",
            "        wait;",
            "    end process;"
        ]))

        f.write("\n")
        f.write("\n")

        f.write("    --**********************************--\n")
        f.write("    --* INSTANTIATE ARITHMETICAL UNITS *--\n")
        f.write("    --**********************************--\n")

        for l in range(len(neurons)):
            # For each layer
            f.write("\n")
            f.write("    --- Layer " + str(l) + " ---\n")
            if l == 0:
                r = range(input_dim)
            else:
                r = range(neurons[l - 1])

            for n in range(neurons[l]):
                # For each neuron in the layer
                f.write("    -- neuron " + str(n) + " --\n")

                # Multiplication units
                for pn in r:
                    # For each neuron in the previous layer
                    umul = str(l) + "_" + str(n) + "_" + str(pn)
                    f.write("\n".join([
                        "    umult" + umul + ": FPP_MULT port map",
                        "    (   A        => " + ("input" if l == 0 else ("result" + str(l-1) + "_")) + str(pn) + ",",
                        "        B        => " + "W" + umul + ",",
                        "        clk      => clk,",
                        "        reset    => reset,",
                        "        go       => go_mul" + umul + ",",
                        "        done     => done_mul" + umul + ",",
                        "        overflow => open,",
                        "        result   => rmul" + umul + " );"
                    ]))
                    f.write("\n")
                    f.write("\n")

                # Addition units
                uadd = str(l) + "_" + str(n)
                f.write("\n".join([
                    "    uadd" + uadd + ": FPP_ADD_SUB port map",
                    "    (   A        => A" + uadd + ",",
                    "        B        => B" + uadd + ",",
                    "        clk      => clk,",
                    "        reset    => reset,",
                    "        go       => go_add" + uadd + ",",
                    "        done     => done_add" + uadd + ",",
                    "        result   => radd" + uadd + " );"
                ]))

                f.write("\n")
                f.write("\n")

                # Activation function units
                af = str(l) + "_" + str(n)
                f.write("\n".join([
                    "    af" + af + ": hard_sigmoid port map",
                    "    (   X        => radd" + af + ",",
                    "        clk      => clk,",
                    "        reset    => reset,",
                    "        go       => go_af" + af + ",",
                    "        done     => done_af" + af + ",",
                    "        result   => result" + af + " );"
                ]))

                f.write("\n")
                f.write("\n")

        f.write("    --****************--\n")
        f.write("    --* MAIN PROCESS *--\n")
        f.write("    --****************--\n")

        f.write("\n")

        f.write("\n".join([
            "    MAIN: process (clk, reset, state) is begin",
            "    if reset = '1' then",
            "        -- Initialization",
            "        state <= NN_BEGIN;",
        ]))

        f.write("\n")

        for l in range(len(neurons)):
            # For each layer
            if l == 0:
                r = range(input_dim)
            else:
                r = range(neurons[l - 1])
            for n in range(neurons[l]):
                # For each neuron in the layer
                sfx = str(l) + "_" + str(n)
                for pn in r:
                    # For each neuron in the previous layer
                    f.write("        go_mul" + sfx + "_" + str(pn) + " <= '0';\n")
                f.write("        go_add" + sfx + " <= '0';\n")
                f.write("        go_af" + sfx + " <= '0';\n")

        f.write("    elsif falling_edge(clk) then\n")
        f.write("        case state is\n")
        f.write("            when NN_BEGIN =>\n")

        for l in range(len(neurons)):
            # For each layer
            if l == 0:
                r = range(input_dim)
                r1 = range(input_dim - 1)
            else:
                r = range(neurons[l - 1])
                r1 = range(neurons[l - 1] - 1)

            if l == 0:
                tab = ""
            else:
                tab = "    "
            muls = []
            for n in range(neurons[l]):
                for pn in r:
                    muls.append(str(l) + "_" + str(n) + "_" + str(pn))
            for m in muls:
                f.write(tab + "                go_mul" + m + " <= '1';\n")
            f.write(tab + "                state <= LAYER" + str(l) + "_MUL;\n")
            if l != 0:
                f.write("                end if;\n")
            f.write("            ------\n")
            f.write("            when LAYER" + str(l) + "_MUL =>\n")
            f.write("                if " + " and ".join("done_mul" + m + " = '1'" for m in muls) + " then\n")
            for m in muls:
                f.write("                    go_mul" + m + " <= '0';\n")

            adds = range(neurons[l])
            for pn in r1:
                # For each neuron in the previous layer - 1
                if pn == 0:
                    tab = "    "
                else:
                    tab = ""
                for n in adds:
                    f.write(tab + "                A" + str(l) + "_" + str(n) + " <= " + (("rmul" + str(l) + "_" + str(n) + "_" + str(pn)) if pn == 0 else ("radd" + str(l) + "_" + str(n))) + ";\n")
                    f.write(tab + "                B" + str(l) + "_" + str(n) + " <= rmul" + str(l) + "_" + str(n) + "_" + str(pn + 1) + ";\n")
                    f.write(tab + "                go_add" + str(l) + "_" + str(n) + " <= '1';\n")
                f.write(tab + "                state <= LAYER" + str(l) + "_ADD" + str(pn) + ";\n")
                if pn == 0:
                    f.write("                end if;\n")
                f.write("            ------\n")
                f.write("            when LAYER" + str(l) + "_ADD" + str(pn) + " =>\n")
                f.write("                if " + " and ".join("done_add" + str(l) + "_" + str(n) + " = '1'" for n in adds) + " then\n")
                for n in adds:
                    f.write("                    go_add" + str(l) + "_" + str(n) + " <= '0';\n")

                f.write("                    state <= LAYER" + str(l) + "_ADD" + str(pn) + "ACK;\n")
                f.write("                end if;\n")
                f.write("            ------\n")
                f.write("            when LAYER" + str(l) + "_ADD" + str(pn) + "ACK =>\n")

            for n in adds:
                f.write("                go_add" + str(l) + "_" + str(n) + " <= '1';\n")
            f.write("                state <= LAYER" + str(l) + "_ADDBIAS;\n")
            f.write("            ------\n")
            f.write("            when LAYER" + str(l) + "_ADDBIAS =>\n")
            f.write("                if " + " and ".join("done_add" + str(l) + "_" + str(n) + " = '1'" for n in adds) + " then\n")
            for n in adds:
                f.write("                    go_add" + str(l) + "_" + str(n) + " <= '0';\n")

            afs = range(neurons[l])
            for n in afs:
                f.write("                    go_af" + str(l) + "_" + str(n) + " <= '1';\n")
            f.write("                    state <= LAYER" + str(l) + "_ACTFUNC;\n")
            f.write("                end if;\n")
            f.write("            ------\n")
            f.write("            when LAYER" + str(l) + "_ACTFUNC =>\n")
            f.write("                if " + " and ".join("done_af" + str(l) + "_" + str(n) + " = '1'" for n in afs) + " then\n")
            for n in afs:
                f.write("                    go_af" + str(l) + "_" + str(n) + " <= '0';\n")

        for i in range(neurons[len(neurons) - 1]):
            f.write("                    final_result" + str(i) + " <= result" + str(len(neurons) - 1) + "_" + str(i) + ";\n")
        f.write("\n".join([
            "                    state <= NN_END;",
            "                end if;",
            "            ------",
            "            when NN_END =>",
            "                state <= NN_END; --do nothing",
            "	    end case;",
            "    end if;",
            "    end process;",
            "",
            "END;",
        ]))
        f.write("\n")
